"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[462],{4137:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),p=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=p(e.components);return a.createElement(c.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),h=p(n),d=o,m=h["".concat(c,".").concat(d)]||h[d]||u[d]||r;return n?a.createElement(m,i(i({ref:t},l),{},{components:n})):a.createElement(m,i({ref:t},l))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[h]="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6063:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(7462),o=(n(7294),n(4137));const r={sidebar_position:7},i="Keys",s={unversionedId:"concepts/keys",id:"concepts/keys",title:"Keys",description:"Client Keys consist of an identifier, and a secret value used to identify client machines. APIs can be consumed in three primary ways:",source:"@site/docs/concepts/keys.md",sourceDirName:"concepts",slug:"/concepts/keys",permalink:"/docs/concepts/keys",draft:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"defaultSidebar",previous:{title:"Connections",permalink:"/docs/concepts/connections"},next:{title:"Scopes (OAuth 2.0)",permalink:"/docs/concepts/scopes-oauth"}},c={},p=[],l={toc:p},h="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(h,(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"keys"},"Keys"),(0,o.kt)("p",null,"Client Keys consist of an identifier, and a secret value used to identify client machines. APIs can be consumed in three primary ways: "),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Users accessing APIs over a UI experience"),(0,o.kt)("li",{parentName:"ol"},"3rd party developers accessing User resources via OAuth2.0"),(0,o.kt)("li",{parentName:"ol"},"Client machines performing API operations where a User is not present. ")),(0,o.kt)("p",null,"For the latter two scenarios, Client Keys enable API developers to perform machine authentication, authorization and auditing (3xA). The key lifecycle is a bit different depending on the scenario in which it is used, therefore it's helpful to walk through these scenarios in detail."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Scenario 1 - Using API Keys for machine-to-machine API operations")),(0,o.kt)("p",null,"When a client machine needs to programmatically access an API, it must establish identity before its\u2019 allowed access to a developers APIs. In this scenario, an API customer would navigate to the Katanemo CIAM console for the SaaS application and create a Key. This process generates a key Id and secret which are used for authentication, authorization and auditing (3xA). Every Key generated in Katanemo must be associated with a Role, which limits operations to the ones supported in the Role. For information on Roles, please refer to docs ",(0,o.kt)("a",{parentName:"p",href:"./roles"},"here"),"."),(0,o.kt)("p",null,"When a client machine wants to make an API call it uses the Katanemo SDK to generate a JWT session token based on its key id and key secret, and uses that JWT session token in the HTTP Authorization Headers to perform API operations against the SaaS application. SaaS developers simply integrate the Katanemo SDK or use one of our managed gateway integrations for authentication, authorization and auditing (3xA). Once Katanemo completes authorization, the SaaS application returns the API call response to the customer."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Scenario  2 - API Keys for user-delegated-access via OAuth2.0")),(0,o.kt)("p",null,"When a 3rd party developer wants to integrate with an API service to operate on protected resources it needs to establish an identity before its allowed access to the API service. To establish an identity, the 3rd party developer must navigate to the Katanemo API Service Console and create a Client Key. "),(0,o.kt)("p",null,"In this scenario, a 3rd party developer needs a JWT access token that contains appropriate OAuth2.0 claims to access a protected resource from a user pool belonging to an API subscriber. Once a Client Key is created, the 3rd party developer must navigate users to the Katanemo ",(0,o.kt)("inlineCode",{parentName:"p"},"/oauth/authorize")," endpoint with relevant OAuth2.0 ",(0,o.kt)("a",{parentName:"p",href:"./scopes-oauth"},"Scopes"),". Note, each ",(0,o.kt)("a",{parentName:"p",href:"./service"},"OpenAPI service")," gets managed ",(0,o.kt)("inlineCode",{parentName:"p"},"/login"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"/oauth/authorize"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"/oauth/token")," endpoints. "),(0,o.kt)("p",null,"The Katanemo ",(0,o.kt)("inlineCode",{parentName:"p"},"/oauth/authorize")," endpoint first identifies the API subscriber domain that a user belongs to and then redirects to the appropriate Idp for an authorization grant. Once an OAuth2.0 JWT is issued, the 3rd party developer calls the API service endpoint with that token, which gets checked for authorization (e.g resource tags) by the Katanemo ",(0,o.kt)("a",{parentName:"p",href:"#"},"evaluation engine"),". Once the API call is authorized, the token is passed to the API service for further processing. In this case, the Role associated with the Key is not used for authorization because the OAuth2.0 claims have the necessary permissions."),(0,o.kt)("p",null,"Once a key is created, you can download the key id/secret pair via the CIAM administrative experience hosted by Katanemo. You will need the Katanemo SDK to exchange the long-lived keys for short-term JWT session tokens for authorization purposes. When session tokens are generated they contain the appropriate role claims in the token for authorization. For more information on tokens, see ",(0,o.kt)("a",{parentName:"p",href:"./crypto-offload-and-sessions-tokens"},"Session Tokens"),"."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Note: The primary reason to use a short-lived token is to defend against ",(0,o.kt)("a",{parentName:"em",href:"https://en.wikipedia.org/wiki/Session_hijacking"},"session hijacking"),", when an adversary, through one method or another, steals session credentials (in this case, the token) and acts maliciously in the victim's session. The shorter-lived the token, the less time the attacker has to carry out whatever malicious activity they have planned.")))}u.isMDXComponent=!0}}]);