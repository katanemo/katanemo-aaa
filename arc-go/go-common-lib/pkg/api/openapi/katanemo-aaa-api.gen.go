// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// AssignRoleObj defines model for AssignRoleObj.
type AssignRoleObj struct {
	PrincipalId string `json:"principalId"`
	RoleId      string `json:"roleId"`
}

// AssumeRoleObj defines model for AssumeRoleObj.
type AssumeRoleObj struct {
	PrincipalId string `json:"principalId"`
	RoleId      string `json:"roleId"`
}

// AttributeRoleMapping defines model for AttributeRoleMapping.
type AttributeRoleMapping struct {
	Attribute string `json:"attribute"`
	RoleId    string `json:"roleId"`
	Value     string `json:"value"`
}

// AuditLogEntry defines model for AuditLogEntry.
type AuditLogEntry struct {
	AccountId          string `json:"accountId"`
	AuthenticationCode int    `json:"authenticationCode"`
	AuthorizationCode  int    `json:"authorizationCode"`
	Operation          string `json:"operation"`
	Path               string `json:"path"`
	Principal          string `json:"principal"`
	ServiceId          string `json:"serviceId"`
}

// ClientKeyObject defines model for ClientKeyObject.
type ClientKeyObject struct {
	AccountId   *string   `json:"accountId,omitempty"`
	ClientKeyId *string   `json:"clientKeyId,omitempty"`
	ClientName  *string   `json:"clientName,omitempty"`
	IsActive    *bool     `json:"isActive,omitempty"`
	Roles       *[]string `json:"roles,omitempty"`
	ServiceId   *string   `json:"serviceId,omitempty"`
}

// ClientKeyRequest defines model for ClientKeyRequest.
type ClientKeyRequest struct {
	ClientName    string `json:"clientName"`
	DefaultRoleId string `json:"defaultRoleId"`
}

// ClientKeyResponse defines model for ClientKeyResponse.
type ClientKeyResponse struct {
	ClientId     *string `json:"clientId,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty"`
}

// CreateServiceRequest defines model for CreateServiceRequest.
type CreateServiceRequest struct {
	// ApiSpecFile openapi service json or yaml file
	ApiSpecFile openapi_types.File `json:"apiSpecFile"`

	// Description Service Description
	Description string `json:"description"`

	// DisplayName Display name of the service/company used in the Sign up, Login, Logout and other relevant branding pages
	DisplayName *string `json:"displayName,omitempty"`

	// DocsUrl The URL for the documentatio of the service
	DocsUrl *string `json:"docsUrl,omitempty"`

	// LogoUrl The URL for the service/company Logo used in the Sign up, Login, Logout and other relevant branding pages
	LogoUrl *string `json:"logoUrl,omitempty"`

	// Name Service Name
	Name string `json:"name"`

	// PrivacyUrl The URL for the privacy of the service
	PrivacyUrl *string `json:"privacyUrl,omitempty"`

	// RedirectUrl Redirect URL after a successful login.
	RedirectUrl string `json:"redirectUrl"`

	// TermsUrl The URL for the terms of the service
	TermsUrl *string `json:"termsUrl,omitempty"`
}

// Error defines model for Error.
type Error struct {
	// Code Error code
	Code int32 `json:"code"`

	// Message Error message
	Message string `json:"message"`
}

// InitArcResponse defines model for InitArcResponse.
type InitArcResponse struct {
	Expiration   *int    `json:"expiration,omitempty"`
	KeyId        *string `json:"keyId,omitempty"`
	KeySecret    *string `json:"keySecret,omitempty"`
	QueueUrl     *string `json:"queueUrl,omitempty"`
	SessionToken *string `json:"sessionToken,omitempty"`
}

// InitialLoginRequest defines model for InitialLoginRequest.
type InitialLoginRequest struct {
	// EmailAddress Email address of the developer account's user
	EmailAddress string `json:"emailAddress"`
}

// InitialLoginResponse defines model for InitialLoginResponse.
type InitialLoginResponse struct {
	// SsoEnabled Determines if sso is enabled or not
	SsoEnabled bool `json:"ssoEnabled"`

	// SsoRedirectUrl If sso is enabled then have to make call to sso endpoint for authentication
	SsoRedirectUrl *string `json:"ssoRedirectUrl,omitempty"`
}

// LoginToken defines model for LoginToken.
type LoginToken struct {
	// Token Login Token
	Token string `json:"token"`
}

// LoginWithPasswordRequest defines model for LoginWithPasswordRequest.
type LoginWithPasswordRequest struct {
	// EmailAddress Email address of the developer account's user
	EmailAddress string `json:"emailAddress"`

	// Password Password of the user
	Password string `json:"password"`

	// SkipRedirect By default login will redirect to service redirect URL, if this parameter is set as true then response will be returned.
	SkipRedirect *bool `json:"skipRedirect,omitempty"`
}

// OAuthTokenRequest defines model for OAuthTokenRequest.
type OAuthTokenRequest struct {
	ClientId     *string `json:"clientId,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty"`
}

// OAuthTokenResponse defines model for OAuthTokenResponse.
type OAuthTokenResponse struct {
	AccessToken *string `json:"accessToken,omitempty"`
	ExpiresIn   *int    `json:"expiresIn,omitempty"`
	TokenType   *string `json:"tokenType,omitempty"`
}

// OIDCPublicKey defines model for OIDCPublicKey.
type OIDCPublicKey struct {
	// Alg Key algorithm
	Alg *string `json:"alg,omitempty"`

	// E RSA exponent
	E *string `json:"e,omitempty"`

	// Kid key id
	Kid *string `json:"kid,omitempty"`

	// Kty key type
	Kty *string `json:"kty,omitempty"`

	// N RSA modulus
	N *string `json:"n,omitempty"`

	// Use key usage
	Use *string `json:"use,omitempty"`
}

// OktaObj defines model for OktaObj.
type OktaObj struct {
	AccountId             *string `json:"accountId,omitempty"`
	AuthorizationEndpoint *string `json:"authorizationEndpoint,omitempty"`
	ClientId              string  `json:"clientId"`
	ClientSecret          string  `json:"clientSecret"`
	ConnectionId          *string `json:"connectionId,omitempty"`
	IssuerEndpoint        *string `json:"issuerEndpoint,omitempty"`
	Nonce                 *string `json:"nonce,omitempty"`

	// OrgName Okta organization name
	OrgName          string  `json:"orgName"`
	ServiceId        *string `json:"serviceId,omitempty"`
	State            *string `json:"state,omitempty"`
	TokenEndpoint    *string `json:"tokenEndpoint,omitempty"`
	UserInfoEndpoint *string `json:"userInfoEndpoint,omitempty"`
}

// Organization defines model for Organization.
type Organization struct {
	AccountId            string    `json:"accountId"`
	AdminAccount         string    `json:"adminAccount"`
	LaunchedServices     *[]string `json:"launchedServices,omitempty"`
	Name                 string    `json:"name"`
	OidcConnectionsCount *int      `json:"oidcConnectionsCount,omitempty"`
	RolesCount           *int      `json:"rolesCount,omitempty"`
	SamlConnectionsCount *int      `json:"samlConnectionsCount,omitempty"`
	SubscribedServices   *[]string `json:"subscribedServices,omitempty"`
	Subscribers          *[]string `json:"subscribers,omitempty"`
	UsersCount           *int      `json:"usersCount,omitempty"`
}

// PasswordPolicy defines model for PasswordPolicy.
type PasswordPolicy struct {
	// MinimumLegnth The minimum length of the password in the policy that you have set. This value can't be less than 6.
	MinimumLegnth int32 `json:"minimumLegnth"`

	// RequireLowerCase In the password policy that you have set, refers to whether you have required users to use at least one lowercase letter in their password.
	RequireLowerCase bool `json:"requireLowerCase"`

	// RequireSymbols In the password policy that you have set, refers to whether you have required users to use at least one symbol in their password.
	RequireSymbols bool `json:"requireSymbols"`

	// RequireUpperCase In the password policy that you have set, refers to whether you have required users to use at least one uppercase letter in their password.
	RequireUpperCase bool `json:"requireUpperCase"`

	// RequiredNumbers In the password policy that you have set, refers to whether you have required users to use at least one number in their password.
	RequiredNumbers bool `json:"requiredNumbers"`
}

// Policy defines model for Policy.
type Policy struct {
	// PolicyContent Policy rules for allowing API paths, it can be defined as json or yaml format.
	PolicyContent string `json:"policyContent"`
}

// Role defines model for Role.
type Role struct {
	// AccountId AccountId
	AccountId *string `json:"accountId,omitempty"`
	CreatedAt *int64  `json:"createdAt,omitempty"`
	Policy    *Policy `json:"policy,omitempty"`

	// RoleId Role Id
	RoleId *string `json:"roleId,omitempty"`

	// Rolename Role name
	Rolename *string `json:"rolename,omitempty"`

	// ServiceId ID of the service
	ServiceId *string `json:"serviceId,omitempty"`
	UpdatedAt *int64  `json:"updatedAt,omitempty"`
	Version   *int    `json:"version,omitempty"`
}

// SAMLObj defines model for SAMLObj.
type SAMLObj struct {
	AccountId             string                  `json:"accountId"`
	AcsLink               *string                 `json:"acsLink,omitempty"`
	AttributeRoleMappings *[]AttributeRoleMapping `json:"attributeRoleMappings,omitempty"`
	AudienceLink          *string                 `json:"audienceLink,omitempty"`
	ConnectionId          *string                 `json:"connectionId,omitempty"`
	DefaultRoleId         string                  `json:"defaultRoleId"`
	IdProvider            string                  `json:"idProvider"`
	LoginLink             *string                 `json:"loginLink,omitempty"`
	MetadataLink          *string                 `json:"metadataLink,omitempty"`
	RootURL               *string                 `json:"rootURL,omitempty"`
	ServiceId             string                  `json:"serviceId"`
}

// ServiceResponseObj defines model for ServiceResponseObj.
type ServiceResponseObj struct {
	// AccountId Account ID of service creator
	AccountId *string `json:"accountId,omitempty"`

	// ApiSpecFileContents S3 url of open api spec (Json or yaml) file contents
	ApiSpecFileContents string `json:"apiSpecFileContents"`

	// Apis List of paths exposed by the service
	Apis      []string `json:"apis"`
	CreatedAt *int64   `json:"createdAt,omitempty"`

	// Description Description of service
	Description string `json:"description"`

	// DisplayName Display name of the service/company used in the Sign up, Login, Logout and other relevant branding pages
	DisplayName *string `json:"displayName,omitempty"`

	// DocsUrl The URL for the documentatio of the service
	DocsUrl *string `json:"docsUrl,omitempty"`

	// LogoUrl The URL for the service/company Logo used in the Sign up, Login, Logout and other relevant branding pages
	LogoUrl *string `json:"logoUrl,omitempty"`

	// OnboardURL Pretty onboarding URL for the service generated by Katanemo
	OnboardURL string `json:"onboardURL"`

	// PrivacyUrl The URL for the privacy of the service
	PrivacyUrl *string `json:"privacyUrl,omitempty"`

	// RedirectUrl redirect url
	RedirectUrl string `json:"redirectUrl"`

	// ServiceId ID of the service
	ServiceId string `json:"serviceId"`

	// ServiceName Name of the service
	ServiceName string `json:"serviceName"`

	// TermsUrl The URL for the terms of the service
	TermsUrl  *string `json:"termsUrl,omitempty"`
	UpdatedAt *int64  `json:"updatedAt,omitempty"`
	Version   *int    `json:"version,omitempty"`
}

// SetPasswordRequest defines model for SetPasswordRequest.
type SetPasswordRequest struct {
	// EmailAddress Email address of the user.
	EmailAddress string `json:"emailAddress"`

	// Password Password of the user for the user to be used in future.
	Password string `json:"password"`

	// Session Session information of the user from confirm user respoonse.
	Session string `json:"session"`
}

// SignupRequest defines model for SignupRequest.
type SignupRequest struct {
	// EmailAddress Email address of user signing up for the service.
	EmailAddress string `json:"emailAddress"`
}

// SignupResponse defines model for SignupResponse.
type SignupResponse struct {
	// AccountId Account ID of developer signed up.
	AccountId string `json:"accountId"`
}

// Tags defines model for Tags.
type Tags struct {
	AccountId     *string             `json:"accountId,omitempty"`
	Name          string              `json:"name"`
	ResourceId    string              `json:"resourceId"`
	ServiceId     string              `json:"serviceId"`
	ServiceIdPath *string             `json:"serviceIdPath,omitempty"`
	Tags          map[string][]string `json:"tags"`
	Token         string              `json:"token"`
}

// UpdateServiceRequest defines model for UpdateServiceRequest.
type UpdateServiceRequest struct {
	// ApiSpecFile openapi service json or yaml file
	ApiSpecFile *openapi_types.File `json:"apiSpecFile,omitempty"`

	// Description Service Description
	Description *string `json:"description,omitempty"`

	// DisplayName Display name of the service/company used in the Sign up, Login, Logout and other relevant branding pages
	DisplayName *string `json:"displayName,omitempty"`

	// DocsUrl The URL for the documentatio of the service
	DocsUrl *string `json:"docsUrl,omitempty"`

	// LogoUrl The URL for the service/company Logo used in the Sign up, Login, Logout and other relevant branding pages
	LogoUrl *string `json:"logoUrl,omitempty"`

	// Name Service Name
	Name *string `json:"name,omitempty"`

	// PrivacyUrl The URL for the privacy of the service
	PrivacyUrl *string `json:"privacyUrl,omitempty"`

	// RedirectUrl Redirect URL after a successful login.
	RedirectUrl *string `json:"redirectUrl,omitempty"`

	// TermsUrl The URL for the terms of the service
	TermsUrl *string `json:"termsUrl,omitempty"`
}

// User defines model for User.
type User struct {
	// AccountId Tenant name
	AccountId string `json:"accountId"`

	// IsActive Is the user active yet?
	IsActive *bool `json:"isActive,omitempty"`

	// IsAdmin is the user an admin?
	IsAdmin *bool     `json:"isAdmin,omitempty"`
	Roles   *[]string `json:"roles,omitempty"`

	// ServiceId Service ID which this account subscribed to
	ServiceId *string              `json:"serviceId,omitempty"`
	Tags      *map[string][]string `json:"tags,omitempty"`

	// Token User token
	Token *string `json:"token,omitempty"`

	// UserId User name (email)
	UserId *string `json:"userId,omitempty"`
}

// UserConfirmationResponse defines model for UserConfirmationResponse.
type UserConfirmationResponse struct {
	// AccountId returns the account id for the organization that subscribed to the service.
	AccountId string `json:"accountId"`

	// EmailAddress returns the email address of the user signing up.
	EmailAddress string `json:"emailAddress"`

	// ServiceId returns the service id for which user subscribed to.
	ServiceId string `json:"serviceId"`

	// Session Session info in response to confirm user. This session can be used to set password.
	Session string `json:"session"`
}

// GetRolesForServiceParams defines parameters for GetRolesForService.
type GetRolesForServiceParams struct {
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTagsForServiceParams defines parameters for GetTagsForService.
type GetTagsForServiceParams struct {
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetAuditLogsParams defines parameters for GetAuditLogs.
type GetAuditLogsParams struct {
	// StartTime Start time of log entries
	StartTime string `form:"startTime" json:"startTime"`

	// EndTime End time of log entries
	EndTime string `form:"endTime" json:"endTime"`
}

// OidcSSOCallBackParams defines parameters for OidcSSOCallBack.
type OidcSSOCallBackParams struct {
	// Code Authorization code returned by the OIDC provider
	Code string `form:"code" json:"code"`

	// State Authorization code returned by the OIDC provider
	State string `form:"state" json:"state"`
}

// SamlSSOCallBackFormdataBody defines parameters for SamlSSOCallBack.
type SamlSSOCallBackFormdataBody struct {
	// SAMLResponse SAML response returned by the SAML IDP
	SAMLResponse *string `json:"SAMLResponse,omitempty"`
}

// SamlSSOCallBackParams defines parameters for SamlSSOCallBack.
type SamlSSOCallBackParams struct {
	// SAMLResponse SAML response returned by the SAML IDP
	SAMLResponse *string `form:"SAMLResponse,omitempty" json:"SAMLResponse,omitempty"`
}

// AssignRoleToPrincipalJSONRequestBody defines body for AssignRoleToPrincipal for application/json ContentType.
type AssignRoleToPrincipalJSONRequestBody = AssignRoleObj

// AssumeRoleJSONRequestBody defines body for AssumeRole for application/json ContentType.
type AssumeRoleJSONRequestBody = AssumeRoleObj

// LoginInitJSONRequestBody defines body for LoginInit for application/json ContentType.
type LoginInitJSONRequestBody = InitialLoginRequest

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody = LoginWithPasswordRequest

// CreateClientKeyJSONRequestBody defines body for CreateClientKey for application/json ContentType.
type CreateClientKeyJSONRequestBody = ClientKeyRequest

// GetOAuthTokenJSONRequestBody defines body for GetOAuthToken for application/json ContentType.
type GetOAuthTokenJSONRequestBody = OAuthTokenRequest

// CreateRoleJSONRequestBody defines body for CreateRole for application/json ContentType.
type CreateRoleJSONRequestBody = Role

// UpdateRoleJSONRequestBody defines body for UpdateRole for application/json ContentType.
type UpdateRoleJSONRequestBody = Role

// CreateOIDCCOnnectionJSONRequestBody defines body for CreateOIDCCOnnection for application/json ContentType.
type CreateOIDCCOnnectionJSONRequestBody = OktaObj

// UpdateOIDCConnectionJSONRequestBody defines body for UpdateOIDCConnection for application/json ContentType.
type UpdateOIDCConnectionJSONRequestBody = OktaObj

// CreateSAMLConnectionJSONRequestBody defines body for CreateSAMLConnection for application/json ContentType.
type CreateSAMLConnectionJSONRequestBody = SAMLObj

// UpdateSAMLConnectionJSONRequestBody defines body for UpdateSAMLConnection for application/json ContentType.
type UpdateSAMLConnectionJSONRequestBody = SAMLObj

// CreateSAMLConnectionMappingJSONRequestBody defines body for CreateSAMLConnectionMapping for application/json ContentType.
type CreateSAMLConnectionMappingJSONRequestBody = AttributeRoleMapping

// SamlSSOCallBackFormdataRequestBody defines body for SamlSSOCallBack for application/x-www-form-urlencoded ContentType.
type SamlSSOCallBackFormdataRequestBody SamlSSOCallBackFormdataBody

// CreateTagsJSONRequestBody defines body for CreateTags for application/json ContentType.
type CreateTagsJSONRequestBody = Tags

// CreateUserForAccountJSONRequestBody defines body for CreateUserForAccount for application/json ContentType.
type CreateUserForAccountJSONRequestBody = User

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = User

// CreateServiceMultipartRequestBody defines body for CreateService for multipart/form-data ContentType.
type CreateServiceMultipartRequestBody = CreateServiceRequest

// UpdateServiceMultipartRequestBody defines body for UpdateService for multipart/form-data ContentType.
type UpdateServiceMultipartRequestBody = UpdateServiceRequest

// SetPasswordJSONRequestBody defines body for SetPassword for application/json ContentType.
type SetPasswordJSONRequestBody = SetPasswordRequest

// ServiceSignupJSONRequestBody defines body for ServiceSignup for application/json ContentType.
type ServiceSignupJSONRequestBody = SignupRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// InitArcClient request
	InitArcClient(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRolesForService request
	GetRolesForService(ctx context.Context, serviceId string, params *GetRolesForServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTagsForService request
	GetTagsForService(ctx context.Context, serviceId string, params *GetTagsForServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignRoleToPrincipal request with any body
	AssignRoleToPrincipalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssignRoleToPrincipal(ctx context.Context, body AssignRoleToPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssumeRole request with any body
	AssumeRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssumeRole(ctx context.Context, body AssumeRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuditLogs request
	GetAuditLogs(ctx context.Context, serviceId string, accountId string, params *GetAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfirmUser request
	ConfirmUser(ctx context.Context, confirmationCode string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHealthz request
	GetHealthz(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginInit request with any body
	LoginInitWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LoginInit(ctx context.Context, serviceId string, body LoginInitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Login request with any body
	LoginWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, serviceId string, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccountOrganization request
	GetAccountOrganization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccountInfo request
	GetAccountInfo(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClientKey request
	DeleteClientKey(ctx context.Context, accountId string, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientKey request
	GetClientKey(ctx context.Context, accountId string, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientKeyList request
	GetClientKeyList(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientKey request with any body
	CreateClientKeyWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClientKey(ctx context.Context, accountId string, body CreateClientKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOAuthToken request with any body
	GetOAuthTokenWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetOAuthToken(ctx context.Context, accountId string, body GetOAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRolesForAccount request
	GetRolesForAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRole request with any body
	CreateRoleWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRole(ctx context.Context, accountId string, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRole request
	GetRole(ctx context.Context, accountId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRole request with any body
	UpdateRoleWithBody(ctx context.Context, accountId string, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRole(ctx context.Context, accountId string, roleId string, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOIDCConnectionsForAccount request
	GetOIDCConnectionsForAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOIDCCOnnection request with any body
	CreateOIDCCOnnectionWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOIDCCOnnection(ctx context.Context, accountId string, body CreateOIDCCOnnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOIDCConnection request
	DeleteOIDCConnection(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOIDCConnection request
	GetOIDCConnection(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOIDCConnection request with any body
	UpdateOIDCConnectionWithBody(ctx context.Context, accountId string, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOIDCConnection(ctx context.Context, accountId string, connectionId string, body UpdateOIDCConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OIDCLoginTrigger request
	OIDCLoginTrigger(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OidcSSOCallBack request
	OidcSSOCallBack(ctx context.Context, accountId string, connectionId string, params *OidcSSOCallBackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSAMLConnectionsForAccount request
	GetSAMLConnectionsForAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSAMLConnection request with any body
	CreateSAMLConnectionWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSAMLConnection(ctx context.Context, accountId string, body CreateSAMLConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSAMLConnection request
	GetSAMLConnection(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSAMLConnection request with any body
	UpdateSAMLConnectionWithBody(ctx context.Context, accountId string, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSAMLConnection(ctx context.Context, accountId string, connectionId string, body UpdateSAMLConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SAMLLoginTrigger request
	SAMLLoginTrigger(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSAMLConnectionMapping request with any body
	CreateSAMLConnectionMappingWithBody(ctx context.Context, accountId string, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSAMLConnectionMapping(ctx context.Context, accountId string, connectionId string, body CreateSAMLConnectionMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SamlSSOCallBack request with any body
	SamlSSOCallBackWithBody(ctx context.Context, accountId string, connectionId string, params *SamlSSOCallBackParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SamlSSOCallBackWithFormdataBody(ctx context.Context, accountId string, connectionId string, params *SamlSSOCallBackParams, body SamlSSOCallBackFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTags request with any body
	CreateTagsWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTags(ctx context.Context, accountId string, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTagsForResource request
	GetTagsForResource(ctx context.Context, accountId string, serviceId string, name string, resourceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersForAccount request
	GetUsersForAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserForAccount request with any body
	CreateUserForAccountWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserForAccount(ctx context.Context, accountId string, body CreateUserForAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, accountId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUser request with any body
	UpdateUserWithBody(ctx context.Context, accountId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, accountId string, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServicesByDeveloper request
	ListServicesByDeveloper(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateService request with any body
	CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultService request
	GetDefaultService(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteService request
	DeleteService(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetService request
	GetService(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateService request with any body
	UpdateServiceWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeveloperPublicKeys request
	GetDeveloperPublicKeys(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPasswordPolicy request
	GetPasswordPolicy(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPassword request with any body
	SetPasswordWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetPassword(ctx context.Context, serviceId string, body SetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ServiceSignup request with any body
	ServiceSignupWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ServiceSignup(ctx context.Context, serviceId string, body ServiceSignupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) InitArcClient(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitArcClientRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRolesForService(ctx context.Context, serviceId string, params *GetRolesForServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolesForServiceRequest(c.Server, serviceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTagsForService(ctx context.Context, serviceId string, params *GetTagsForServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsForServiceRequest(c.Server, serviceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignRoleToPrincipalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignRoleToPrincipalRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignRoleToPrincipal(ctx context.Context, body AssignRoleToPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignRoleToPrincipalRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssumeRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssumeRoleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssumeRole(ctx context.Context, body AssumeRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssumeRoleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuditLogs(ctx context.Context, serviceId string, accountId string, params *GetAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuditLogsRequest(c.Server, serviceId, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmUser(ctx context.Context, confirmationCode string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmUserRequest(c.Server, confirmationCode)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHealthz(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHealthzRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginInitWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginInitRequestWithBody(c.Server, serviceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginInit(ctx context.Context, serviceId string, body LoginInitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginInitRequest(c.Server, serviceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, serviceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, serviceId string, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, serviceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountOrganization(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountOrganizationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountInfo(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountInfoRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClientKey(ctx context.Context, accountId string, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClientKeyRequest(c.Server, accountId, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientKey(ctx context.Context, accountId string, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientKeyRequest(c.Server, accountId, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientKeyList(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientKeyListRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientKeyWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientKeyRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientKey(ctx context.Context, accountId string, body CreateClientKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientKeyRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthTokenWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthTokenRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthToken(ctx context.Context, accountId string, body GetOAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthTokenRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRolesForAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolesForAccountRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRole(ctx context.Context, accountId string, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRole(ctx context.Context, accountId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleRequest(c.Server, accountId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleWithBody(ctx context.Context, accountId string, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequestWithBody(c.Server, accountId, roleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRole(ctx context.Context, accountId string, roleId string, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequest(c.Server, accountId, roleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOIDCConnectionsForAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOIDCConnectionsForAccountRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOIDCCOnnectionWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOIDCCOnnectionRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOIDCCOnnection(ctx context.Context, accountId string, body CreateOIDCCOnnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOIDCCOnnectionRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOIDCConnection(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOIDCConnectionRequest(c.Server, accountId, connectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOIDCConnection(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOIDCConnectionRequest(c.Server, accountId, connectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOIDCConnectionWithBody(ctx context.Context, accountId string, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOIDCConnectionRequestWithBody(c.Server, accountId, connectionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOIDCConnection(ctx context.Context, accountId string, connectionId string, body UpdateOIDCConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOIDCConnectionRequest(c.Server, accountId, connectionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OIDCLoginTrigger(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOIDCLoginTriggerRequest(c.Server, accountId, connectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OidcSSOCallBack(ctx context.Context, accountId string, connectionId string, params *OidcSSOCallBackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOidcSSOCallBackRequest(c.Server, accountId, connectionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSAMLConnectionsForAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSAMLConnectionsForAccountRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSAMLConnectionWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSAMLConnectionRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSAMLConnection(ctx context.Context, accountId string, body CreateSAMLConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSAMLConnectionRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSAMLConnection(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSAMLConnectionRequest(c.Server, accountId, connectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSAMLConnectionWithBody(ctx context.Context, accountId string, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSAMLConnectionRequestWithBody(c.Server, accountId, connectionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSAMLConnection(ctx context.Context, accountId string, connectionId string, body UpdateSAMLConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSAMLConnectionRequest(c.Server, accountId, connectionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SAMLLoginTrigger(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSAMLLoginTriggerRequest(c.Server, accountId, connectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSAMLConnectionMappingWithBody(ctx context.Context, accountId string, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSAMLConnectionMappingRequestWithBody(c.Server, accountId, connectionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSAMLConnectionMapping(ctx context.Context, accountId string, connectionId string, body CreateSAMLConnectionMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSAMLConnectionMappingRequest(c.Server, accountId, connectionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SamlSSOCallBackWithBody(ctx context.Context, accountId string, connectionId string, params *SamlSSOCallBackParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSamlSSOCallBackRequestWithBody(c.Server, accountId, connectionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SamlSSOCallBackWithFormdataBody(ctx context.Context, accountId string, connectionId string, params *SamlSSOCallBackParams, body SamlSSOCallBackFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSamlSSOCallBackRequestWithFormdataBody(c.Server, accountId, connectionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagsWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagsRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTags(ctx context.Context, accountId string, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagsRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTagsForResource(ctx context.Context, accountId string, serviceId string, name string, resourceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsForResourceRequest(c.Server, accountId, serviceId, name, resourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersForAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersForAccountRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserForAccountWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserForAccountRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserForAccount(ctx context.Context, accountId string, body CreateUserForAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserForAccountRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, accountId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, accountId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, accountId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, accountId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, accountId string, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, accountId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServicesByDeveloper(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServicesByDeveloperRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultService(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultServiceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteService(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetService(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceRequestWithBody(c.Server, serviceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeveloperPublicKeys(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeveloperPublicKeysRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPasswordPolicy(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPasswordPolicyRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPasswordWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPasswordRequestWithBody(c.Server, serviceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPassword(ctx context.Context, serviceId string, body SetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPasswordRequest(c.Server, serviceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceSignupWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServiceSignupRequestWithBody(c.Server, serviceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceSignup(ctx context.Context, serviceId string, body ServiceSignupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServiceSignupRequest(c.Server, serviceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewInitArcClientRequest generates requests for InitArcClient
func NewInitArcClientRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/arc/%s/init", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRolesForServiceRequest generates requests for GetRolesForService
func NewGetRolesForServiceRequest(server string, serviceId string, params *GetRolesForServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/arc/%s/role", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagsForServiceRequest generates requests for GetTagsForService
func NewGetTagsForServiceRequest(server string, serviceId string, params *GetTagsForServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/arc/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignRoleToPrincipalRequest calls the generic AssignRoleToPrincipal builder with application/json body
func NewAssignRoleToPrincipalRequest(server string, body AssignRoleToPrincipalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssignRoleToPrincipalRequestWithBody(server, "application/json", bodyReader)
}

// NewAssignRoleToPrincipalRequestWithBody generates requests for AssignRoleToPrincipal with any type of body
func NewAssignRoleToPrincipalRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assignrole")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssumeRoleRequest calls the generic AssumeRole builder with application/json body
func NewAssumeRoleRequest(server string, body AssumeRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssumeRoleRequestWithBody(server, "application/json", bodyReader)
}

// NewAssumeRoleRequestWithBody generates requests for AssumeRole with any type of body
func NewAssumeRoleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assumeRole")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAuditLogsRequest generates requests for GetAuditLogs
func NewGetAuditLogsRequest(server string, serviceId string, accountId string, params *GetAuditLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audit-logs/service/%s/account/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTime", runtime.ParamLocationQuery, params.StartTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endTime", runtime.ParamLocationQuery, params.EndTime); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfirmUserRequest generates requests for ConfirmUser
func NewConfirmUserRequest(server string, confirmationCode string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "confirmationCode", runtime.ParamLocationPath, confirmationCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/confirmUser/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHealthzRequest generates requests for GetHealthz
func NewGetHealthzRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/healthz")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginInitRequest calls the generic LoginInit builder with application/json body
func NewLoginInitRequest(server string, serviceId string, body LoginInitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginInitRequestWithBody(server, serviceId, "application/json", bodyReader)
}

// NewLoginInitRequestWithBody generates requests for LoginInit with any type of body
func NewLoginInitRequestWithBody(server string, serviceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/login-init/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, serviceId string, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, serviceId, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, serviceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/login/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAccountOrganizationRequest generates requests for GetAccountOrganization
func NewGetAccountOrganizationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccountInfoRequest generates requests for GetAccountInfo
func NewGetAccountInfoRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteClientKeyRequest generates requests for DeleteClientKey
func NewDeleteClientKeyRequest(server string, accountId string, keyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/key/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientKeyRequest generates requests for GetClientKey
func NewGetClientKeyRequest(server string, accountId string, keyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "keyId", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/key/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientKeyListRequest generates requests for GetClientKeyList
func NewGetClientKeyListRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClientKeyRequest calls the generic CreateClientKey builder with application/json body
func NewCreateClientKeyRequest(server string, accountId string, body CreateClientKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientKeyRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewCreateClientKeyRequestWithBody generates requests for CreateClientKey with any type of body
func NewCreateClientKeyRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOAuthTokenRequest calls the generic GetOAuthToken builder with application/json body
func NewGetOAuthTokenRequest(server string, accountId string, body GetOAuthTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetOAuthTokenRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewGetOAuthTokenRequestWithBody generates requests for GetOAuthToken with any type of body
func NewGetOAuthTokenRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/oauth/token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRolesForAccountRequest generates requests for GetRolesForAccount
func NewGetRolesForAccountRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/role", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRoleRequest calls the generic CreateRole builder with application/json body
func NewCreateRoleRequest(server string, accountId string, body CreateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRoleRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewCreateRoleRequestWithBody generates requests for CreateRole with any type of body
func NewCreateRoleRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/role", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRoleRequest generates requests for GetRole
func NewGetRoleRequest(server string, accountId string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/role/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRoleRequest calls the generic UpdateRole builder with application/json body
func NewUpdateRoleRequest(server string, accountId string, roleId string, body UpdateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRoleRequestWithBody(server, accountId, roleId, "application/json", bodyReader)
}

// NewUpdateRoleRequestWithBody generates requests for UpdateRole with any type of body
func NewUpdateRoleRequestWithBody(server string, accountId string, roleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/role/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOIDCConnectionsForAccountRequest generates requests for GetOIDCConnectionsForAccount
func NewGetOIDCConnectionsForAccountRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/sso-connections/oidc", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOIDCCOnnectionRequest calls the generic CreateOIDCCOnnection builder with application/json body
func NewCreateOIDCCOnnectionRequest(server string, accountId string, body CreateOIDCCOnnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOIDCCOnnectionRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewCreateOIDCCOnnectionRequestWithBody generates requests for CreateOIDCCOnnection with any type of body
func NewCreateOIDCCOnnectionRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/sso-connections/oidc", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOIDCConnectionRequest generates requests for DeleteOIDCConnection
func NewDeleteOIDCConnectionRequest(server string, accountId string, connectionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/sso-connections/oidc/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOIDCConnectionRequest generates requests for GetOIDCConnection
func NewGetOIDCConnectionRequest(server string, accountId string, connectionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/sso-connections/oidc/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOIDCConnectionRequest calls the generic UpdateOIDCConnection builder with application/json body
func NewUpdateOIDCConnectionRequest(server string, accountId string, connectionId string, body UpdateOIDCConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOIDCConnectionRequestWithBody(server, accountId, connectionId, "application/json", bodyReader)
}

// NewUpdateOIDCConnectionRequestWithBody generates requests for UpdateOIDCConnection with any type of body
func NewUpdateOIDCConnectionRequestWithBody(server string, accountId string, connectionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/sso-connections/oidc/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOIDCLoginTriggerRequest generates requests for OIDCLoginTrigger
func NewOIDCLoginTriggerRequest(server string, accountId string, connectionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/sso-connections/oidc/%s/login-trigger", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOidcSSOCallBackRequest generates requests for OidcSSOCallBack
func NewOidcSSOCallBackRequest(server string, accountId string, connectionId string, params *OidcSSOCallBackParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/sso-connections/oidc/%s/sso-callback", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, params.Code); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSAMLConnectionsForAccountRequest generates requests for GetSAMLConnectionsForAccount
func NewGetSAMLConnectionsForAccountRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/sso-connections/saml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSAMLConnectionRequest calls the generic CreateSAMLConnection builder with application/json body
func NewCreateSAMLConnectionRequest(server string, accountId string, body CreateSAMLConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSAMLConnectionRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewCreateSAMLConnectionRequestWithBody generates requests for CreateSAMLConnection with any type of body
func NewCreateSAMLConnectionRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/sso-connections/saml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSAMLConnectionRequest generates requests for GetSAMLConnection
func NewGetSAMLConnectionRequest(server string, accountId string, connectionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/sso-connections/saml/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSAMLConnectionRequest calls the generic UpdateSAMLConnection builder with application/json body
func NewUpdateSAMLConnectionRequest(server string, accountId string, connectionId string, body UpdateSAMLConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSAMLConnectionRequestWithBody(server, accountId, connectionId, "application/json", bodyReader)
}

// NewUpdateSAMLConnectionRequestWithBody generates requests for UpdateSAMLConnection with any type of body
func NewUpdateSAMLConnectionRequestWithBody(server string, accountId string, connectionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/sso-connections/saml/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSAMLLoginTriggerRequest generates requests for SAMLLoginTrigger
func NewSAMLLoginTriggerRequest(server string, accountId string, connectionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/sso-connections/saml/%s/login-trigger", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSAMLConnectionMappingRequest calls the generic CreateSAMLConnectionMapping builder with application/json body
func NewCreateSAMLConnectionMappingRequest(server string, accountId string, connectionId string, body CreateSAMLConnectionMappingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSAMLConnectionMappingRequestWithBody(server, accountId, connectionId, "application/json", bodyReader)
}

// NewCreateSAMLConnectionMappingRequestWithBody generates requests for CreateSAMLConnectionMapping with any type of body
func NewCreateSAMLConnectionMappingRequestWithBody(server string, accountId string, connectionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/sso-connections/saml/%s/mapAttributeToRoles", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSamlSSOCallBackRequestWithFormdataBody calls the generic SamlSSOCallBack builder with application/x-www-form-urlencoded body
func NewSamlSSOCallBackRequestWithFormdataBody(server string, accountId string, connectionId string, params *SamlSSOCallBackParams, body SamlSSOCallBackFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSamlSSOCallBackRequestWithBody(server, accountId, connectionId, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewSamlSSOCallBackRequestWithBody generates requests for SamlSSOCallBack with any type of body
func NewSamlSSOCallBackRequestWithBody(server string, accountId string, connectionId string, params *SamlSSOCallBackParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/sso-connections/saml/%s/sso-callback/saml/acs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.SAMLResponse != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "SAMLResponse", runtime.ParamLocationQuery, *params.SAMLResponse); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTagsRequest calls the generic CreateTags builder with application/json body
func NewCreateTagsRequest(server string, accountId string, body CreateTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTagsRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewCreateTagsRequestWithBody generates requests for CreateTags with any type of body
func NewCreateTagsRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTagsForResourceRequest generates requests for GetTagsForResource
func NewGetTagsForResourceRequest(server string, accountId string, serviceId string, name string, resourceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "resourceId", runtime.ParamLocationPath, resourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/tags/serviceId/%s/name/%s/resource/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersForAccountRequest generates requests for GetUsersForAccount
func NewGetUsersForAccountRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/user", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserForAccountRequest calls the generic CreateUserForAccount builder with application/json body
func NewCreateUserForAccountRequest(server string, accountId string, body CreateUserForAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserForAccountRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewCreateUserForAccountRequestWithBody generates requests for CreateUserForAccount with any type of body
func NewCreateUserForAccountRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/user", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, accountId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/user/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, accountId string, userId string, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, accountId, userId, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, accountId string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/user/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListServicesByDeveloperRequest generates requests for ListServicesByDeveloper
func NewListServicesByDeveloperRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServiceRequestWithBody generates requests for CreateService with any type of body
func NewCreateServiceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDefaultServiceRequest generates requests for GetDefaultService
func NewGetDefaultServiceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/3xA")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteServiceRequest generates requests for DeleteService
func NewDeleteServiceRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceRequest generates requests for GetService
func NewGetServiceRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServiceRequestWithBody generates requests for UpdateService with any type of body
func NewUpdateServiceRequestWithBody(server string, serviceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDeveloperPublicKeysRequest generates requests for GetDeveloperPublicKeys
func NewGetDeveloperPublicKeysRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/%s/.well-known/jwks.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPasswordPolicyRequest generates requests for GetPasswordPolicy
func NewGetPasswordPolicyRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/set-password/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPasswordRequest calls the generic SetPassword builder with application/json body
func NewSetPasswordRequest(server string, serviceId string, body SetPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetPasswordRequestWithBody(server, serviceId, "application/json", bodyReader)
}

// NewSetPasswordRequestWithBody generates requests for SetPassword with any type of body
func NewSetPasswordRequestWithBody(server string, serviceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/set-password/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewServiceSignupRequest calls the generic ServiceSignup builder with application/json body
func NewServiceSignupRequest(server string, serviceId string, body ServiceSignupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewServiceSignupRequestWithBody(server, serviceId, "application/json", bodyReader)
}

// NewServiceSignupRequestWithBody generates requests for ServiceSignup with any type of body
func NewServiceSignupRequestWithBody(server string, serviceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sign-up/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// InitArcClient request
	InitArcClientWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*InitArcClientResponse, error)

	// GetRolesForService request
	GetRolesForServiceWithResponse(ctx context.Context, serviceId string, params *GetRolesForServiceParams, reqEditors ...RequestEditorFn) (*GetRolesForServiceResponse, error)

	// GetTagsForService request
	GetTagsForServiceWithResponse(ctx context.Context, serviceId string, params *GetTagsForServiceParams, reqEditors ...RequestEditorFn) (*GetTagsForServiceResponse, error)

	// AssignRoleToPrincipal request with any body
	AssignRoleToPrincipalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignRoleToPrincipalResponse, error)

	AssignRoleToPrincipalWithResponse(ctx context.Context, body AssignRoleToPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignRoleToPrincipalResponse, error)

	// AssumeRole request with any body
	AssumeRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssumeRoleResponse, error)

	AssumeRoleWithResponse(ctx context.Context, body AssumeRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*AssumeRoleResponse, error)

	// GetAuditLogs request
	GetAuditLogsWithResponse(ctx context.Context, serviceId string, accountId string, params *GetAuditLogsParams, reqEditors ...RequestEditorFn) (*GetAuditLogsResponse, error)

	// ConfirmUser request
	ConfirmUserWithResponse(ctx context.Context, confirmationCode string, reqEditors ...RequestEditorFn) (*ConfirmUserResponse, error)

	// GetHealthz request
	GetHealthzWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthzResponse, error)

	// LoginInit request with any body
	LoginInitWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginInitResponse, error)

	LoginInitWithResponse(ctx context.Context, serviceId string, body LoginInitJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginInitResponse, error)

	// Login request with any body
	LoginWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, serviceId string, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// GetAccountOrganization request
	GetAccountOrganizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAccountOrganizationResponse, error)

	// GetAccountInfo request
	GetAccountInfoWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetAccountInfoResponse, error)

	// DeleteClientKey request
	DeleteClientKeyWithResponse(ctx context.Context, accountId string, keyId string, reqEditors ...RequestEditorFn) (*DeleteClientKeyResponse, error)

	// GetClientKey request
	GetClientKeyWithResponse(ctx context.Context, accountId string, keyId string, reqEditors ...RequestEditorFn) (*GetClientKeyResponse, error)

	// GetClientKeyList request
	GetClientKeyListWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetClientKeyListResponse, error)

	// CreateClientKey request with any body
	CreateClientKeyWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientKeyResponse, error)

	CreateClientKeyWithResponse(ctx context.Context, accountId string, body CreateClientKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientKeyResponse, error)

	// GetOAuthToken request with any body
	GetOAuthTokenWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error)

	GetOAuthTokenWithResponse(ctx context.Context, accountId string, body GetOAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error)

	// GetRolesForAccount request
	GetRolesForAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetRolesForAccountResponse, error)

	// CreateRole request with any body
	CreateRoleWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error)

	CreateRoleWithResponse(ctx context.Context, accountId string, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error)

	// GetRole request
	GetRoleWithResponse(ctx context.Context, accountId string, roleId string, reqEditors ...RequestEditorFn) (*GetRoleResponse, error)

	// UpdateRole request with any body
	UpdateRoleWithBodyWithResponse(ctx context.Context, accountId string, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	UpdateRoleWithResponse(ctx context.Context, accountId string, roleId string, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	// GetOIDCConnectionsForAccount request
	GetOIDCConnectionsForAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetOIDCConnectionsForAccountResponse, error)

	// CreateOIDCCOnnection request with any body
	CreateOIDCCOnnectionWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOIDCCOnnectionResponse, error)

	CreateOIDCCOnnectionWithResponse(ctx context.Context, accountId string, body CreateOIDCCOnnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOIDCCOnnectionResponse, error)

	// DeleteOIDCConnection request
	DeleteOIDCConnectionWithResponse(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*DeleteOIDCConnectionResponse, error)

	// GetOIDCConnection request
	GetOIDCConnectionWithResponse(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*GetOIDCConnectionResponse, error)

	// UpdateOIDCConnection request with any body
	UpdateOIDCConnectionWithBodyWithResponse(ctx context.Context, accountId string, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOIDCConnectionResponse, error)

	UpdateOIDCConnectionWithResponse(ctx context.Context, accountId string, connectionId string, body UpdateOIDCConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOIDCConnectionResponse, error)

	// OIDCLoginTrigger request
	OIDCLoginTriggerWithResponse(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*OIDCLoginTriggerResponse, error)

	// OidcSSOCallBack request
	OidcSSOCallBackWithResponse(ctx context.Context, accountId string, connectionId string, params *OidcSSOCallBackParams, reqEditors ...RequestEditorFn) (*OidcSSOCallBackResponse, error)

	// GetSAMLConnectionsForAccount request
	GetSAMLConnectionsForAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetSAMLConnectionsForAccountResponse, error)

	// CreateSAMLConnection request with any body
	CreateSAMLConnectionWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSAMLConnectionResponse, error)

	CreateSAMLConnectionWithResponse(ctx context.Context, accountId string, body CreateSAMLConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSAMLConnectionResponse, error)

	// GetSAMLConnection request
	GetSAMLConnectionWithResponse(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*GetSAMLConnectionResponse, error)

	// UpdateSAMLConnection request with any body
	UpdateSAMLConnectionWithBodyWithResponse(ctx context.Context, accountId string, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSAMLConnectionResponse, error)

	UpdateSAMLConnectionWithResponse(ctx context.Context, accountId string, connectionId string, body UpdateSAMLConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSAMLConnectionResponse, error)

	// SAMLLoginTrigger request
	SAMLLoginTriggerWithResponse(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*SAMLLoginTriggerResponse, error)

	// CreateSAMLConnectionMapping request with any body
	CreateSAMLConnectionMappingWithBodyWithResponse(ctx context.Context, accountId string, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSAMLConnectionMappingResponse, error)

	CreateSAMLConnectionMappingWithResponse(ctx context.Context, accountId string, connectionId string, body CreateSAMLConnectionMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSAMLConnectionMappingResponse, error)

	// SamlSSOCallBack request with any body
	SamlSSOCallBackWithBodyWithResponse(ctx context.Context, accountId string, connectionId string, params *SamlSSOCallBackParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SamlSSOCallBackResponse, error)

	SamlSSOCallBackWithFormdataBodyWithResponse(ctx context.Context, accountId string, connectionId string, params *SamlSSOCallBackParams, body SamlSSOCallBackFormdataRequestBody, reqEditors ...RequestEditorFn) (*SamlSSOCallBackResponse, error)

	// CreateTags request with any body
	CreateTagsWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error)

	CreateTagsWithResponse(ctx context.Context, accountId string, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error)

	// GetTagsForResource request
	GetTagsForResourceWithResponse(ctx context.Context, accountId string, serviceId string, name string, resourceId string, reqEditors ...RequestEditorFn) (*GetTagsForResourceResponse, error)

	// GetUsersForAccount request
	GetUsersForAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetUsersForAccountResponse, error)

	// CreateUserForAccount request with any body
	CreateUserForAccountWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserForAccountResponse, error)

	CreateUserForAccountWithResponse(ctx context.Context, accountId string, body CreateUserForAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserForAccountResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, accountId string, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// UpdateUser request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, accountId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, accountId string, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// ListServicesByDeveloper request
	ListServicesByDeveloperWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListServicesByDeveloperResponse, error)

	// CreateService request with any body
	CreateServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error)

	// GetDefaultService request
	GetDefaultServiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultServiceResponse, error)

	// DeleteService request
	DeleteServiceWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*DeleteServiceResponse, error)

	// GetService request
	GetServiceWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServiceResponse, error)

	// UpdateService request with any body
	UpdateServiceWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceResponse, error)

	// GetDeveloperPublicKeys request
	GetDeveloperPublicKeysWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetDeveloperPublicKeysResponse, error)

	// GetPasswordPolicy request
	GetPasswordPolicyWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetPasswordPolicyResponse, error)

	// SetPassword request with any body
	SetPasswordWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPasswordResponse, error)

	SetPasswordWithResponse(ctx context.Context, serviceId string, body SetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPasswordResponse, error)

	// ServiceSignup request with any body
	ServiceSignupWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ServiceSignupResponse, error)

	ServiceSignupWithResponse(ctx context.Context, serviceId string, body ServiceSignupJSONRequestBody, reqEditors ...RequestEditorFn) (*ServiceSignupResponse, error)
}

type InitArcClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]InitArcResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InitArcClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InitArcClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRolesForServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Role
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRolesForServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRolesForServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsForServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Tags
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetTagsForServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsForServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignRoleToPrincipalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AssignRoleToPrincipalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignRoleToPrincipalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssumeRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AssumeRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssumeRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuditLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AuditLogEntry
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAuditLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuditLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserConfirmationResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ConfirmUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHealthzResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetHealthzResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHealthzResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginInitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InitialLoginResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LoginInitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginInitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginToken
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Organization
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAccountOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Organization
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAccountInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClientKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteClientKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClientKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClientKeyObject
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetClientKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientKeyListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClientKeyObject
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetClientKeyListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientKeyListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClientKeyResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateClientKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOAuthTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthTokenResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetOAuthTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOAuthTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRolesForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Role
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRolesForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRolesForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Role
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Role
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Role
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOIDCConnectionsForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OktaObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetOIDCConnectionsForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOIDCConnectionsForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOIDCCOnnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OktaObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateOIDCCOnnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOIDCCOnnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOIDCConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteOIDCConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOIDCConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOIDCConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OktaObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetOIDCConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOIDCConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOIDCConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OktaObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateOIDCConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOIDCConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OIDCLoginTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r OIDCLoginTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OIDCLoginTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OidcSSOCallBackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r OidcSSOCallBackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OidcSSOCallBackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSAMLConnectionsForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SAMLObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSAMLConnectionsForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSAMLConnectionsForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSAMLConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SAMLObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateSAMLConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSAMLConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSAMLConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SAMLObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSAMLConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSAMLConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSAMLConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SAMLObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateSAMLConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSAMLConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SAMLLoginTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SAMLLoginTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SAMLLoginTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSAMLConnectionMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SAMLObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateSAMLConnectionMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSAMLConnectionMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SamlSSOCallBackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SamlSSOCallBackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SamlSSOCallBackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tags
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsForResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tags
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetTagsForResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsForResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]User
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUsersForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServicesByDeveloperResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ServiceResponseObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListServicesByDeveloperResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServicesByDeveloperResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceResponseObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceResponseObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetDefaultServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceResponseObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceResponseObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeveloperPublicKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Keys *[]OIDCPublicKey `json:"keys,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetDeveloperPublicKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeveloperPublicKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPasswordPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PasswordPolicy
}

// Status returns HTTPResponse.Status
func (r GetPasswordPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPasswordPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ServiceSignupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SignupResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ServiceSignupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ServiceSignupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// InitArcClientWithResponse request returning *InitArcClientResponse
func (c *ClientWithResponses) InitArcClientWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*InitArcClientResponse, error) {
	rsp, err := c.InitArcClient(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitArcClientResponse(rsp)
}

// GetRolesForServiceWithResponse request returning *GetRolesForServiceResponse
func (c *ClientWithResponses) GetRolesForServiceWithResponse(ctx context.Context, serviceId string, params *GetRolesForServiceParams, reqEditors ...RequestEditorFn) (*GetRolesForServiceResponse, error) {
	rsp, err := c.GetRolesForService(ctx, serviceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolesForServiceResponse(rsp)
}

// GetTagsForServiceWithResponse request returning *GetTagsForServiceResponse
func (c *ClientWithResponses) GetTagsForServiceWithResponse(ctx context.Context, serviceId string, params *GetTagsForServiceParams, reqEditors ...RequestEditorFn) (*GetTagsForServiceResponse, error) {
	rsp, err := c.GetTagsForService(ctx, serviceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsForServiceResponse(rsp)
}

// AssignRoleToPrincipalWithBodyWithResponse request with arbitrary body returning *AssignRoleToPrincipalResponse
func (c *ClientWithResponses) AssignRoleToPrincipalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignRoleToPrincipalResponse, error) {
	rsp, err := c.AssignRoleToPrincipalWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignRoleToPrincipalResponse(rsp)
}

func (c *ClientWithResponses) AssignRoleToPrincipalWithResponse(ctx context.Context, body AssignRoleToPrincipalJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignRoleToPrincipalResponse, error) {
	rsp, err := c.AssignRoleToPrincipal(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignRoleToPrincipalResponse(rsp)
}

// AssumeRoleWithBodyWithResponse request with arbitrary body returning *AssumeRoleResponse
func (c *ClientWithResponses) AssumeRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssumeRoleResponse, error) {
	rsp, err := c.AssumeRoleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssumeRoleResponse(rsp)
}

func (c *ClientWithResponses) AssumeRoleWithResponse(ctx context.Context, body AssumeRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*AssumeRoleResponse, error) {
	rsp, err := c.AssumeRole(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssumeRoleResponse(rsp)
}

// GetAuditLogsWithResponse request returning *GetAuditLogsResponse
func (c *ClientWithResponses) GetAuditLogsWithResponse(ctx context.Context, serviceId string, accountId string, params *GetAuditLogsParams, reqEditors ...RequestEditorFn) (*GetAuditLogsResponse, error) {
	rsp, err := c.GetAuditLogs(ctx, serviceId, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuditLogsResponse(rsp)
}

// ConfirmUserWithResponse request returning *ConfirmUserResponse
func (c *ClientWithResponses) ConfirmUserWithResponse(ctx context.Context, confirmationCode string, reqEditors ...RequestEditorFn) (*ConfirmUserResponse, error) {
	rsp, err := c.ConfirmUser(ctx, confirmationCode, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmUserResponse(rsp)
}

// GetHealthzWithResponse request returning *GetHealthzResponse
func (c *ClientWithResponses) GetHealthzWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthzResponse, error) {
	rsp, err := c.GetHealthz(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHealthzResponse(rsp)
}

// LoginInitWithBodyWithResponse request with arbitrary body returning *LoginInitResponse
func (c *ClientWithResponses) LoginInitWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginInitResponse, error) {
	rsp, err := c.LoginInitWithBody(ctx, serviceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginInitResponse(rsp)
}

func (c *ClientWithResponses) LoginInitWithResponse(ctx context.Context, serviceId string, body LoginInitJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginInitResponse, error) {
	rsp, err := c.LoginInit(ctx, serviceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginInitResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, serviceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, serviceId string, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, serviceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// GetAccountOrganizationWithResponse request returning *GetAccountOrganizationResponse
func (c *ClientWithResponses) GetAccountOrganizationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAccountOrganizationResponse, error) {
	rsp, err := c.GetAccountOrganization(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountOrganizationResponse(rsp)
}

// GetAccountInfoWithResponse request returning *GetAccountInfoResponse
func (c *ClientWithResponses) GetAccountInfoWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetAccountInfoResponse, error) {
	rsp, err := c.GetAccountInfo(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountInfoResponse(rsp)
}

// DeleteClientKeyWithResponse request returning *DeleteClientKeyResponse
func (c *ClientWithResponses) DeleteClientKeyWithResponse(ctx context.Context, accountId string, keyId string, reqEditors ...RequestEditorFn) (*DeleteClientKeyResponse, error) {
	rsp, err := c.DeleteClientKey(ctx, accountId, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClientKeyResponse(rsp)
}

// GetClientKeyWithResponse request returning *GetClientKeyResponse
func (c *ClientWithResponses) GetClientKeyWithResponse(ctx context.Context, accountId string, keyId string, reqEditors ...RequestEditorFn) (*GetClientKeyResponse, error) {
	rsp, err := c.GetClientKey(ctx, accountId, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientKeyResponse(rsp)
}

// GetClientKeyListWithResponse request returning *GetClientKeyListResponse
func (c *ClientWithResponses) GetClientKeyListWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetClientKeyListResponse, error) {
	rsp, err := c.GetClientKeyList(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientKeyListResponse(rsp)
}

// CreateClientKeyWithBodyWithResponse request with arbitrary body returning *CreateClientKeyResponse
func (c *ClientWithResponses) CreateClientKeyWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientKeyResponse, error) {
	rsp, err := c.CreateClientKeyWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateClientKeyWithResponse(ctx context.Context, accountId string, body CreateClientKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientKeyResponse, error) {
	rsp, err := c.CreateClientKey(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientKeyResponse(rsp)
}

// GetOAuthTokenWithBodyWithResponse request with arbitrary body returning *GetOAuthTokenResponse
func (c *ClientWithResponses) GetOAuthTokenWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error) {
	rsp, err := c.GetOAuthTokenWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthTokenResponse(rsp)
}

func (c *ClientWithResponses) GetOAuthTokenWithResponse(ctx context.Context, accountId string, body GetOAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error) {
	rsp, err := c.GetOAuthToken(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthTokenResponse(rsp)
}

// GetRolesForAccountWithResponse request returning *GetRolesForAccountResponse
func (c *ClientWithResponses) GetRolesForAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetRolesForAccountResponse, error) {
	rsp, err := c.GetRolesForAccount(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolesForAccountResponse(rsp)
}

// CreateRoleWithBodyWithResponse request with arbitrary body returning *CreateRoleResponse
func (c *ClientWithResponses) CreateRoleWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error) {
	rsp, err := c.CreateRoleWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleResponse(rsp)
}

func (c *ClientWithResponses) CreateRoleWithResponse(ctx context.Context, accountId string, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error) {
	rsp, err := c.CreateRole(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleResponse(rsp)
}

// GetRoleWithResponse request returning *GetRoleResponse
func (c *ClientWithResponses) GetRoleWithResponse(ctx context.Context, accountId string, roleId string, reqEditors ...RequestEditorFn) (*GetRoleResponse, error) {
	rsp, err := c.GetRole(ctx, accountId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleResponse(rsp)
}

// UpdateRoleWithBodyWithResponse request with arbitrary body returning *UpdateRoleResponse
func (c *ClientWithResponses) UpdateRoleWithBodyWithResponse(ctx context.Context, accountId string, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRoleWithBody(ctx, accountId, roleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRoleWithResponse(ctx context.Context, accountId string, roleId string, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRole(ctx, accountId, roleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

// GetOIDCConnectionsForAccountWithResponse request returning *GetOIDCConnectionsForAccountResponse
func (c *ClientWithResponses) GetOIDCConnectionsForAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetOIDCConnectionsForAccountResponse, error) {
	rsp, err := c.GetOIDCConnectionsForAccount(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOIDCConnectionsForAccountResponse(rsp)
}

// CreateOIDCCOnnectionWithBodyWithResponse request with arbitrary body returning *CreateOIDCCOnnectionResponse
func (c *ClientWithResponses) CreateOIDCCOnnectionWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOIDCCOnnectionResponse, error) {
	rsp, err := c.CreateOIDCCOnnectionWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOIDCCOnnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateOIDCCOnnectionWithResponse(ctx context.Context, accountId string, body CreateOIDCCOnnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOIDCCOnnectionResponse, error) {
	rsp, err := c.CreateOIDCCOnnection(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOIDCCOnnectionResponse(rsp)
}

// DeleteOIDCConnectionWithResponse request returning *DeleteOIDCConnectionResponse
func (c *ClientWithResponses) DeleteOIDCConnectionWithResponse(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*DeleteOIDCConnectionResponse, error) {
	rsp, err := c.DeleteOIDCConnection(ctx, accountId, connectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOIDCConnectionResponse(rsp)
}

// GetOIDCConnectionWithResponse request returning *GetOIDCConnectionResponse
func (c *ClientWithResponses) GetOIDCConnectionWithResponse(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*GetOIDCConnectionResponse, error) {
	rsp, err := c.GetOIDCConnection(ctx, accountId, connectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOIDCConnectionResponse(rsp)
}

// UpdateOIDCConnectionWithBodyWithResponse request with arbitrary body returning *UpdateOIDCConnectionResponse
func (c *ClientWithResponses) UpdateOIDCConnectionWithBodyWithResponse(ctx context.Context, accountId string, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOIDCConnectionResponse, error) {
	rsp, err := c.UpdateOIDCConnectionWithBody(ctx, accountId, connectionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOIDCConnectionResponse(rsp)
}

func (c *ClientWithResponses) UpdateOIDCConnectionWithResponse(ctx context.Context, accountId string, connectionId string, body UpdateOIDCConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOIDCConnectionResponse, error) {
	rsp, err := c.UpdateOIDCConnection(ctx, accountId, connectionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOIDCConnectionResponse(rsp)
}

// OIDCLoginTriggerWithResponse request returning *OIDCLoginTriggerResponse
func (c *ClientWithResponses) OIDCLoginTriggerWithResponse(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*OIDCLoginTriggerResponse, error) {
	rsp, err := c.OIDCLoginTrigger(ctx, accountId, connectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOIDCLoginTriggerResponse(rsp)
}

// OidcSSOCallBackWithResponse request returning *OidcSSOCallBackResponse
func (c *ClientWithResponses) OidcSSOCallBackWithResponse(ctx context.Context, accountId string, connectionId string, params *OidcSSOCallBackParams, reqEditors ...RequestEditorFn) (*OidcSSOCallBackResponse, error) {
	rsp, err := c.OidcSSOCallBack(ctx, accountId, connectionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOidcSSOCallBackResponse(rsp)
}

// GetSAMLConnectionsForAccountWithResponse request returning *GetSAMLConnectionsForAccountResponse
func (c *ClientWithResponses) GetSAMLConnectionsForAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetSAMLConnectionsForAccountResponse, error) {
	rsp, err := c.GetSAMLConnectionsForAccount(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSAMLConnectionsForAccountResponse(rsp)
}

// CreateSAMLConnectionWithBodyWithResponse request with arbitrary body returning *CreateSAMLConnectionResponse
func (c *ClientWithResponses) CreateSAMLConnectionWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSAMLConnectionResponse, error) {
	rsp, err := c.CreateSAMLConnectionWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSAMLConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateSAMLConnectionWithResponse(ctx context.Context, accountId string, body CreateSAMLConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSAMLConnectionResponse, error) {
	rsp, err := c.CreateSAMLConnection(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSAMLConnectionResponse(rsp)
}

// GetSAMLConnectionWithResponse request returning *GetSAMLConnectionResponse
func (c *ClientWithResponses) GetSAMLConnectionWithResponse(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*GetSAMLConnectionResponse, error) {
	rsp, err := c.GetSAMLConnection(ctx, accountId, connectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSAMLConnectionResponse(rsp)
}

// UpdateSAMLConnectionWithBodyWithResponse request with arbitrary body returning *UpdateSAMLConnectionResponse
func (c *ClientWithResponses) UpdateSAMLConnectionWithBodyWithResponse(ctx context.Context, accountId string, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSAMLConnectionResponse, error) {
	rsp, err := c.UpdateSAMLConnectionWithBody(ctx, accountId, connectionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSAMLConnectionResponse(rsp)
}

func (c *ClientWithResponses) UpdateSAMLConnectionWithResponse(ctx context.Context, accountId string, connectionId string, body UpdateSAMLConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSAMLConnectionResponse, error) {
	rsp, err := c.UpdateSAMLConnection(ctx, accountId, connectionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSAMLConnectionResponse(rsp)
}

// SAMLLoginTriggerWithResponse request returning *SAMLLoginTriggerResponse
func (c *ClientWithResponses) SAMLLoginTriggerWithResponse(ctx context.Context, accountId string, connectionId string, reqEditors ...RequestEditorFn) (*SAMLLoginTriggerResponse, error) {
	rsp, err := c.SAMLLoginTrigger(ctx, accountId, connectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSAMLLoginTriggerResponse(rsp)
}

// CreateSAMLConnectionMappingWithBodyWithResponse request with arbitrary body returning *CreateSAMLConnectionMappingResponse
func (c *ClientWithResponses) CreateSAMLConnectionMappingWithBodyWithResponse(ctx context.Context, accountId string, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSAMLConnectionMappingResponse, error) {
	rsp, err := c.CreateSAMLConnectionMappingWithBody(ctx, accountId, connectionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSAMLConnectionMappingResponse(rsp)
}

func (c *ClientWithResponses) CreateSAMLConnectionMappingWithResponse(ctx context.Context, accountId string, connectionId string, body CreateSAMLConnectionMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSAMLConnectionMappingResponse, error) {
	rsp, err := c.CreateSAMLConnectionMapping(ctx, accountId, connectionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSAMLConnectionMappingResponse(rsp)
}

// SamlSSOCallBackWithBodyWithResponse request with arbitrary body returning *SamlSSOCallBackResponse
func (c *ClientWithResponses) SamlSSOCallBackWithBodyWithResponse(ctx context.Context, accountId string, connectionId string, params *SamlSSOCallBackParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SamlSSOCallBackResponse, error) {
	rsp, err := c.SamlSSOCallBackWithBody(ctx, accountId, connectionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSamlSSOCallBackResponse(rsp)
}

func (c *ClientWithResponses) SamlSSOCallBackWithFormdataBodyWithResponse(ctx context.Context, accountId string, connectionId string, params *SamlSSOCallBackParams, body SamlSSOCallBackFormdataRequestBody, reqEditors ...RequestEditorFn) (*SamlSSOCallBackResponse, error) {
	rsp, err := c.SamlSSOCallBackWithFormdataBody(ctx, accountId, connectionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSamlSSOCallBackResponse(rsp)
}

// CreateTagsWithBodyWithResponse request with arbitrary body returning *CreateTagsResponse
func (c *ClientWithResponses) CreateTagsWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error) {
	rsp, err := c.CreateTagsWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagsResponse(rsp)
}

func (c *ClientWithResponses) CreateTagsWithResponse(ctx context.Context, accountId string, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error) {
	rsp, err := c.CreateTags(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagsResponse(rsp)
}

// GetTagsForResourceWithResponse request returning *GetTagsForResourceResponse
func (c *ClientWithResponses) GetTagsForResourceWithResponse(ctx context.Context, accountId string, serviceId string, name string, resourceId string, reqEditors ...RequestEditorFn) (*GetTagsForResourceResponse, error) {
	rsp, err := c.GetTagsForResource(ctx, accountId, serviceId, name, resourceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsForResourceResponse(rsp)
}

// GetUsersForAccountWithResponse request returning *GetUsersForAccountResponse
func (c *ClientWithResponses) GetUsersForAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetUsersForAccountResponse, error) {
	rsp, err := c.GetUsersForAccount(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersForAccountResponse(rsp)
}

// CreateUserForAccountWithBodyWithResponse request with arbitrary body returning *CreateUserForAccountResponse
func (c *ClientWithResponses) CreateUserForAccountWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserForAccountResponse, error) {
	rsp, err := c.CreateUserForAccountWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserForAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateUserForAccountWithResponse(ctx context.Context, accountId string, body CreateUserForAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserForAccountResponse, error) {
	rsp, err := c.CreateUserForAccount(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserForAccountResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, accountId string, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, accountId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, accountId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, accountId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, accountId string, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, accountId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// ListServicesByDeveloperWithResponse request returning *ListServicesByDeveloperResponse
func (c *ClientWithResponses) ListServicesByDeveloperWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListServicesByDeveloperResponse, error) {
	rsp, err := c.ListServicesByDeveloper(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServicesByDeveloperResponse(rsp)
}

// CreateServiceWithBodyWithResponse request with arbitrary body returning *CreateServiceResponse
func (c *ClientWithResponses) CreateServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error) {
	rsp, err := c.CreateServiceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceResponse(rsp)
}

// GetDefaultServiceWithResponse request returning *GetDefaultServiceResponse
func (c *ClientWithResponses) GetDefaultServiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultServiceResponse, error) {
	rsp, err := c.GetDefaultService(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultServiceResponse(rsp)
}

// DeleteServiceWithResponse request returning *DeleteServiceResponse
func (c *ClientWithResponses) DeleteServiceWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*DeleteServiceResponse, error) {
	rsp, err := c.DeleteService(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceResponse(rsp)
}

// GetServiceWithResponse request returning *GetServiceResponse
func (c *ClientWithResponses) GetServiceWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServiceResponse, error) {
	rsp, err := c.GetService(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceResponse(rsp)
}

// UpdateServiceWithBodyWithResponse request with arbitrary body returning *UpdateServiceResponse
func (c *ClientWithResponses) UpdateServiceWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceResponse, error) {
	rsp, err := c.UpdateServiceWithBody(ctx, serviceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceResponse(rsp)
}

// GetDeveloperPublicKeysWithResponse request returning *GetDeveloperPublicKeysResponse
func (c *ClientWithResponses) GetDeveloperPublicKeysWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetDeveloperPublicKeysResponse, error) {
	rsp, err := c.GetDeveloperPublicKeys(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeveloperPublicKeysResponse(rsp)
}

// GetPasswordPolicyWithResponse request returning *GetPasswordPolicyResponse
func (c *ClientWithResponses) GetPasswordPolicyWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetPasswordPolicyResponse, error) {
	rsp, err := c.GetPasswordPolicy(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPasswordPolicyResponse(rsp)
}

// SetPasswordWithBodyWithResponse request with arbitrary body returning *SetPasswordResponse
func (c *ClientWithResponses) SetPasswordWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPasswordResponse, error) {
	rsp, err := c.SetPasswordWithBody(ctx, serviceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPasswordResponse(rsp)
}

func (c *ClientWithResponses) SetPasswordWithResponse(ctx context.Context, serviceId string, body SetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPasswordResponse, error) {
	rsp, err := c.SetPassword(ctx, serviceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPasswordResponse(rsp)
}

// ServiceSignupWithBodyWithResponse request with arbitrary body returning *ServiceSignupResponse
func (c *ClientWithResponses) ServiceSignupWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ServiceSignupResponse, error) {
	rsp, err := c.ServiceSignupWithBody(ctx, serviceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServiceSignupResponse(rsp)
}

func (c *ClientWithResponses) ServiceSignupWithResponse(ctx context.Context, serviceId string, body ServiceSignupJSONRequestBody, reqEditors ...RequestEditorFn) (*ServiceSignupResponse, error) {
	rsp, err := c.ServiceSignup(ctx, serviceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServiceSignupResponse(rsp)
}

// ParseInitArcClientResponse parses an HTTP response from a InitArcClientWithResponse call
func ParseInitArcClientResponse(rsp *http.Response) (*InitArcClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InitArcClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []InitArcResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRolesForServiceResponse parses an HTTP response from a GetRolesForServiceWithResponse call
func ParseGetRolesForServiceResponse(rsp *http.Response) (*GetRolesForServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRolesForServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTagsForServiceResponse parses an HTTP response from a GetTagsForServiceWithResponse call
func ParseGetTagsForServiceResponse(rsp *http.Response) (*GetTagsForServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsForServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Tags
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAssignRoleToPrincipalResponse parses an HTTP response from a AssignRoleToPrincipalWithResponse call
func ParseAssignRoleToPrincipalResponse(rsp *http.Response) (*AssignRoleToPrincipalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignRoleToPrincipalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAssumeRoleResponse parses an HTTP response from a AssumeRoleWithResponse call
func ParseAssumeRoleResponse(rsp *http.Response) (*AssumeRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssumeRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAuditLogsResponse parses an HTTP response from a GetAuditLogsWithResponse call
func ParseGetAuditLogsResponse(rsp *http.Response) (*GetAuditLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuditLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AuditLogEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseConfirmUserResponse parses an HTTP response from a ConfirmUserWithResponse call
func ParseConfirmUserResponse(rsp *http.Response) (*ConfirmUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserConfirmationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHealthzResponse parses an HTTP response from a GetHealthzWithResponse call
func ParseGetHealthzResponse(rsp *http.Response) (*GetHealthzResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHealthzResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoginInitResponse parses an HTTP response from a LoginInitWithResponse call
func ParseLoginInitResponse(rsp *http.Response) (*LoginInitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginInitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InitialLoginResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAccountOrganizationResponse parses an HTTP response from a GetAccountOrganizationWithResponse call
func ParseGetAccountOrganizationResponse(rsp *http.Response) (*GetAccountOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAccountInfoResponse parses an HTTP response from a GetAccountInfoWithResponse call
func ParseGetAccountInfoResponse(rsp *http.Response) (*GetAccountInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteClientKeyResponse parses an HTTP response from a DeleteClientKeyWithResponse call
func ParseDeleteClientKeyResponse(rsp *http.Response) (*DeleteClientKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClientKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClientKeyResponse parses an HTTP response from a GetClientKeyWithResponse call
func ParseGetClientKeyResponse(rsp *http.Response) (*GetClientKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClientKeyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClientKeyListResponse parses an HTTP response from a GetClientKeyListWithResponse call
func ParseGetClientKeyListResponse(rsp *http.Response) (*GetClientKeyListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientKeyListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClientKeyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateClientKeyResponse parses an HTTP response from a CreateClientKeyWithResponse call
func ParseCreateClientKeyResponse(rsp *http.Response) (*CreateClientKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClientKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOAuthTokenResponse parses an HTTP response from a GetOAuthTokenWithResponse call
func ParseGetOAuthTokenResponse(rsp *http.Response) (*GetOAuthTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOAuthTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRolesForAccountResponse parses an HTTP response from a GetRolesForAccountWithResponse call
func ParseGetRolesForAccountResponse(rsp *http.Response) (*GetRolesForAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRolesForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateRoleResponse parses an HTTP response from a CreateRoleWithResponse call
func ParseCreateRoleResponse(rsp *http.Response) (*CreateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRoleResponse parses an HTTP response from a GetRoleWithResponse call
func ParseGetRoleResponse(rsp *http.Response) (*GetRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateRoleResponse parses an HTTP response from a UpdateRoleWithResponse call
func ParseUpdateRoleResponse(rsp *http.Response) (*UpdateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOIDCConnectionsForAccountResponse parses an HTTP response from a GetOIDCConnectionsForAccountWithResponse call
func ParseGetOIDCConnectionsForAccountResponse(rsp *http.Response) (*GetOIDCConnectionsForAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOIDCConnectionsForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OktaObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateOIDCCOnnectionResponse parses an HTTP response from a CreateOIDCCOnnectionWithResponse call
func ParseCreateOIDCCOnnectionResponse(rsp *http.Response) (*CreateOIDCCOnnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOIDCCOnnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OktaObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteOIDCConnectionResponse parses an HTTP response from a DeleteOIDCConnectionWithResponse call
func ParseDeleteOIDCConnectionResponse(rsp *http.Response) (*DeleteOIDCConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOIDCConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOIDCConnectionResponse parses an HTTP response from a GetOIDCConnectionWithResponse call
func ParseGetOIDCConnectionResponse(rsp *http.Response) (*GetOIDCConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOIDCConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OktaObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateOIDCConnectionResponse parses an HTTP response from a UpdateOIDCConnectionWithResponse call
func ParseUpdateOIDCConnectionResponse(rsp *http.Response) (*UpdateOIDCConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOIDCConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OktaObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOIDCLoginTriggerResponse parses an HTTP response from a OIDCLoginTriggerWithResponse call
func ParseOIDCLoginTriggerResponse(rsp *http.Response) (*OIDCLoginTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OIDCLoginTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOidcSSOCallBackResponse parses an HTTP response from a OidcSSOCallBackWithResponse call
func ParseOidcSSOCallBackResponse(rsp *http.Response) (*OidcSSOCallBackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OidcSSOCallBackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSAMLConnectionsForAccountResponse parses an HTTP response from a GetSAMLConnectionsForAccountWithResponse call
func ParseGetSAMLConnectionsForAccountResponse(rsp *http.Response) (*GetSAMLConnectionsForAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSAMLConnectionsForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SAMLObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSAMLConnectionResponse parses an HTTP response from a CreateSAMLConnectionWithResponse call
func ParseCreateSAMLConnectionResponse(rsp *http.Response) (*CreateSAMLConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSAMLConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SAMLObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSAMLConnectionResponse parses an HTTP response from a GetSAMLConnectionWithResponse call
func ParseGetSAMLConnectionResponse(rsp *http.Response) (*GetSAMLConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSAMLConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SAMLObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateSAMLConnectionResponse parses an HTTP response from a UpdateSAMLConnectionWithResponse call
func ParseUpdateSAMLConnectionResponse(rsp *http.Response) (*UpdateSAMLConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSAMLConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SAMLObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSAMLLoginTriggerResponse parses an HTTP response from a SAMLLoginTriggerWithResponse call
func ParseSAMLLoginTriggerResponse(rsp *http.Response) (*SAMLLoginTriggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SAMLLoginTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSAMLConnectionMappingResponse parses an HTTP response from a CreateSAMLConnectionMappingWithResponse call
func ParseCreateSAMLConnectionMappingResponse(rsp *http.Response) (*CreateSAMLConnectionMappingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSAMLConnectionMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SAMLObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSamlSSOCallBackResponse parses an HTTP response from a SamlSSOCallBackWithResponse call
func ParseSamlSSOCallBackResponse(rsp *http.Response) (*SamlSSOCallBackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SamlSSOCallBackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTagsResponse parses an HTTP response from a CreateTagsWithResponse call
func ParseCreateTagsResponse(rsp *http.Response) (*CreateTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tags
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTagsForResourceResponse parses an HTTP response from a GetTagsForResourceWithResponse call
func ParseGetTagsForResourceResponse(rsp *http.Response) (*GetTagsForResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsForResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tags
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUsersForAccountResponse parses an HTTP response from a GetUsersForAccountWithResponse call
func ParseGetUsersForAccountResponse(rsp *http.Response) (*GetUsersForAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserForAccountResponse parses an HTTP response from a CreateUserForAccountWithResponse call
func ParseCreateUserForAccountResponse(rsp *http.Response) (*CreateUserForAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListServicesByDeveloperResponse parses an HTTP response from a ListServicesByDeveloperWithResponse call
func ParseListServicesByDeveloperResponse(rsp *http.Response) (*ListServicesByDeveloperResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServicesByDeveloperResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ServiceResponseObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServiceResponse parses an HTTP response from a CreateServiceWithResponse call
func ParseCreateServiceResponse(rsp *http.Response) (*CreateServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceResponseObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDefaultServiceResponse parses an HTTP response from a GetDefaultServiceWithResponse call
func ParseGetDefaultServiceResponse(rsp *http.Response) (*GetDefaultServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceResponseObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServiceResponse parses an HTTP response from a DeleteServiceWithResponse call
func ParseDeleteServiceResponse(rsp *http.Response) (*DeleteServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServiceResponse parses an HTTP response from a GetServiceWithResponse call
func ParseGetServiceResponse(rsp *http.Response) (*GetServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceResponseObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateServiceResponse parses an HTTP response from a UpdateServiceWithResponse call
func ParseUpdateServiceResponse(rsp *http.Response) (*UpdateServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceResponseObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDeveloperPublicKeysResponse parses an HTTP response from a GetDeveloperPublicKeysWithResponse call
func ParseGetDeveloperPublicKeysResponse(rsp *http.Response) (*GetDeveloperPublicKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeveloperPublicKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Keys *[]OIDCPublicKey `json:"keys,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPasswordPolicyResponse parses an HTTP response from a GetPasswordPolicyWithResponse call
func ParseGetPasswordPolicyResponse(rsp *http.Response) (*GetPasswordPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPasswordPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PasswordPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetPasswordResponse parses an HTTP response from a SetPasswordWithResponse call
func ParseSetPasswordResponse(rsp *http.Response) (*SetPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseServiceSignupResponse parses an HTTP response from a ServiceSignupWithResponse call
func ParseServiceSignupResponse(rsp *http.Response) (*ServiceSignupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ServiceSignupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SignupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /arc/{serviceId}/init)
	InitArcClient(ctx echo.Context, serviceId string) error

	// (GET /arc/{serviceId}/role)
	GetRolesForService(ctx echo.Context, serviceId string, params GetRolesForServiceParams) error

	// (GET /arc/{serviceId}/tags)
	GetTagsForService(ctx echo.Context, serviceId string, params GetTagsForServiceParams) error
	// Assign role to an identity principal
	// (POST /assignrole)
	AssignRoleToPrincipal(ctx echo.Context) error
	// Creates a token with requested roleId
	// (POST /assumeRole)
	AssumeRole(ctx echo.Context) error
	// Returns list of log entries for a service and account
	// (GET /audit-logs/service/{serviceId}/account/{accountId})
	GetAuditLogs(ctx echo.Context, serviceId string, accountId string, params GetAuditLogsParams) error
	// Confirm that the user belongs to the organization (email) they signed-up with. Used by Katanemo to verify developers signing-up for its 3xA service and for service developers on-boarding their customers (subscribers)
	// (GET /confirmUser/{confirmationCode})
	ConfirmUser(ctx echo.Context, confirmationCode string) error
	// Returns service health
	// (GET /healthz)
	GetHealthz(ctx echo.Context) error
	// Login-init helps developers determine if the user should be presented a SAML/SSO workflow or a user/password sign-in experience.
	// (POST /login-init/{serviceId})
	LoginInit(ctx echo.Context, serviceId string) error
	// Login to any katanemo service with email and password
	// (POST /login/{serviceId})
	Login(ctx echo.Context, serviceId string) error
	// Returns an object with information regarding an account which is present in the token
	// (GET /org)
	GetAccountOrganization(ctx echo.Context) error
	// Returns an object with information regarding an account
	// (GET /org/{accountId})
	GetAccountInfo(ctx echo.Context, accountId string) error
	// delete a client key
	// (DELETE /org/{accountId}/key/{keyId})
	DeleteClientKey(ctx echo.Context, accountId string, keyId string) error
	// Get details of client key
	// (GET /org/{accountId}/key/{keyId})
	GetClientKey(ctx echo.Context, accountId string, keyId string) error
	// Get list of all client keys
	// (GET /org/{accountId}/keys)
	GetClientKeyList(ctx echo.Context, accountId string) error
	// Creates a new client key
	// (POST /org/{accountId}/keys)
	CreateClientKey(ctx echo.Context, accountId string) error
	// get token for client id / secret
	// (POST /org/{accountId}/oauth/token)
	GetOAuthToken(ctx echo.Context, accountId string) error
	// Returns a list of all roles belonging to provided account ID
	// (GET /org/{accountId}/role)
	GetRolesForAccount(ctx echo.Context, accountId string) error
	// Creates a new Role
	// (POST /org/{accountId}/role)
	CreateRole(ctx echo.Context, accountId string) error
	// Gets a role
	// (GET /org/{accountId}/role/{roleId})
	GetRole(ctx echo.Context, accountId string, roleId string) error
	// Updates role
	// (PUT /org/{accountId}/role/{roleId})
	UpdateRole(ctx echo.Context, accountId string, roleId string) error
	// Returns a list of all OIDC connections belonging to provided account ID
	// (GET /org/{accountId}/sso-connections/oidc)
	GetOIDCConnectionsForAccount(ctx echo.Context, accountId string) error
	// Creates a new OIDC connection
	// (POST /org/{accountId}/sso-connections/oidc)
	CreateOIDCCOnnection(ctx echo.Context, accountId string) error
	// Deletes an OIDC connection
	// (DELETE /org/{accountId}/sso-connections/oidc/{connectionId})
	DeleteOIDCConnection(ctx echo.Context, accountId string, connectionId string) error
	// Retrieves an OIDC connection
	// (GET /org/{accountId}/sso-connections/oidc/{connectionId})
	GetOIDCConnection(ctx echo.Context, accountId string, connectionId string) error
	// Updates a OIDC connection
	// (PUT /org/{accountId}/sso-connections/oidc/{connectionId})
	UpdateOIDCConnection(ctx echo.Context, accountId string, connectionId string) error
	// Triggers okta signin flow
	// (GET /org/{accountId}/sso-connections/oidc/{connectionId}/login-trigger)
	OIDCLoginTrigger(ctx echo.Context, accountId string, connectionId string) error
	// Handle OIDC SSO login callback
	// (GET /org/{accountId}/sso-connections/oidc/{connectionId}/sso-callback)
	OidcSSOCallBack(ctx echo.Context, accountId string, connectionId string, params OidcSSOCallBackParams) error
	// Returns a list of all SAML connections belonging to provided account ID
	// (GET /org/{accountId}/sso-connections/saml)
	GetSAMLConnectionsForAccount(ctx echo.Context, accountId string) error
	// Creates a new SAML connection
	// (POST /org/{accountId}/sso-connections/saml)
	CreateSAMLConnection(ctx echo.Context, accountId string) error
	// Retreive a SAML connection
	// (GET /org/{accountId}/sso-connections/saml/{connectionId})
	GetSAMLConnection(ctx echo.Context, accountId string, connectionId string) error
	// Updates a SAML connection
	// (PUT /org/{accountId}/sso-connections/saml/{connectionId})
	UpdateSAMLConnection(ctx echo.Context, accountId string, connectionId string) error
	// Triggers SAML SSO signin flow
	// (GET /org/{accountId}/sso-connections/saml/{connectionId}/login-trigger)
	SAMLLoginTrigger(ctx echo.Context, accountId string, connectionId string) error
	// Creates a new attribute mapping for a SAML connection
	// (POST /org/{accountId}/sso-connections/saml/{connectionId}/mapAttributeToRoles)
	CreateSAMLConnectionMapping(ctx echo.Context, accountId string, connectionId string) error
	// Handle SAML login callback with SAML assertion. It can be passed as query parameter or payload.
	// (POST /org/{accountId}/sso-connections/saml/{connectionId}/sso-callback/saml/acs)
	SamlSSOCallBack(ctx echo.Context, accountId string, connectionId string, params SamlSSOCallBackParams) error
	// creates a resource with provided tags
	// (POST /org/{accountId}/tags)
	CreateTags(ctx echo.Context, accountId string) error
	// Gets tags for resource
	// (GET /org/{accountId}/tags/serviceId/{serviceId}/name/{name}/resource/{resourceId})
	GetTagsForResource(ctx echo.Context, accountId string, serviceId string, name string, resourceId string) error
	// Returns a list of all users belonging to provided account ID
	// (GET /org/{accountId}/user)
	GetUsersForAccount(ctx echo.Context, accountId string) error
	// Creates a new User account tied to the specified organization
	// (POST /org/{accountId}/user)
	CreateUserForAccount(ctx echo.Context, accountId string) error

	// (GET /org/{accountId}/user/{userId})
	GetUser(ctx echo.Context, accountId string, userId string) error
	// Updates a user
	// (PUT /org/{accountId}/user/{userId})
	UpdateUser(ctx echo.Context, accountId string, userId string) error
	// List services that belong to a particular developer. Requires bearer token authorization
	// (GET /service)
	ListServicesByDeveloper(ctx echo.Context) error
	// Create a Service object.
	// (POST /service)
	CreateService(ctx echo.Context) error
	// Get details about Katanemo's AAA SaaS service. Katanemo is powered by Katanemo, and our 3xA service uses the same core identity and authorization capabilities that we offer SaaS (API) developers
	// (GET /service/3xA)
	GetDefaultService(ctx echo.Context) error
	// Deletes a service with service ID. Note the delete operation is a "soft" delete where by organizations can't access your service. Requires bearer token authorization.
	// (DELETE /service/{serviceId})
	DeleteService(ctx echo.Context, serviceId string) error
	// Gets a service with service ID
	// (GET /service/{serviceId})
	GetService(ctx echo.Context, serviceId string) error
	// Update a Service. Requires bearer token authorization
	// (PUT /service/{serviceId})
	UpdateService(ctx echo.Context, serviceId string) error
	// Gets public key that can be used to verify jwt token issued by Katanemo. This API does not require bearer authorizationn if service is public
	// (GET /service/{serviceId}/.well-known/jwks.json)
	GetDeveloperPublicKeys(ctx echo.Context, serviceId string) error
	// Gets the password policy (length, characters, etc), to help the user set the correct password
	// (GET /set-password/{serviceId})
	GetPasswordPolicy(ctx echo.Context, serviceId string) error
	// Set password after user verification.
	// (POST /set-password/{serviceId})
	SetPassword(ctx echo.Context, serviceId string) error
	// Onborad customers to a particular SaaS service managed by Katanemo
	// (POST /sign-up/{serviceId})
	ServiceSignup(ctx echo.Context, serviceId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// InitArcClient converts echo context to params.
func (w *ServerInterfaceWrapper) InitArcClient(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.InitArcClient(ctx, serviceId)
	return err
}

// GetRolesForService converts echo context to params.
func (w *ServerInterfaceWrapper) GetRolesForService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRolesForServiceParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRolesForService(ctx, serviceId, params)
	return err
}

// GetTagsForService converts echo context to params.
func (w *ServerInterfaceWrapper) GetTagsForService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTagsForServiceParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTagsForService(ctx, serviceId, params)
	return err
}

// AssignRoleToPrincipal converts echo context to params.
func (w *ServerInterfaceWrapper) AssignRoleToPrincipal(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AssignRoleToPrincipal(ctx)
	return err
}

// AssumeRole converts echo context to params.
func (w *ServerInterfaceWrapper) AssumeRole(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AssumeRole(ctx)
	return err
}

// GetAuditLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuditLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuditLogsParams
	// ------------- Required query parameter "startTime" -------------

	err = runtime.BindQueryParameter("form", true, true, "startTime", ctx.QueryParams(), &params.StartTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startTime: %s", err))
	}

	// ------------- Required query parameter "endTime" -------------

	err = runtime.BindQueryParameter("form", true, true, "endTime", ctx.QueryParams(), &params.EndTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endTime: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAuditLogs(ctx, serviceId, accountId, params)
	return err
}

// ConfirmUser converts echo context to params.
func (w *ServerInterfaceWrapper) ConfirmUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "confirmationCode" -------------
	var confirmationCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "confirmationCode", runtime.ParamLocationPath, ctx.Param("confirmationCode"), &confirmationCode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter confirmationCode: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConfirmUser(ctx, confirmationCode)
	return err
}

// GetHealthz converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealthz(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetHealthz(ctx)
	return err
}

// LoginInit converts echo context to params.
func (w *ServerInterfaceWrapper) LoginInit(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LoginInit(ctx, serviceId)
	return err
}

// Login converts echo context to params.
func (w *ServerInterfaceWrapper) Login(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Login(ctx, serviceId)
	return err
}

// GetAccountOrganization converts echo context to params.
func (w *ServerInterfaceWrapper) GetAccountOrganization(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAccountOrganization(ctx)
	return err
}

// GetAccountInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetAccountInfo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAccountInfo(ctx, accountId)
	return err
}

// DeleteClientKey converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteClientKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "keyId" -------------
	var keyId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "keyId", runtime.ParamLocationPath, ctx.Param("keyId"), &keyId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keyId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteClientKey(ctx, accountId, keyId)
	return err
}

// GetClientKey converts echo context to params.
func (w *ServerInterfaceWrapper) GetClientKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "keyId" -------------
	var keyId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "keyId", runtime.ParamLocationPath, ctx.Param("keyId"), &keyId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keyId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetClientKey(ctx, accountId, keyId)
	return err
}

// GetClientKeyList converts echo context to params.
func (w *ServerInterfaceWrapper) GetClientKeyList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetClientKeyList(ctx, accountId)
	return err
}

// CreateClientKey converts echo context to params.
func (w *ServerInterfaceWrapper) CreateClientKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateClientKey(ctx, accountId)
	return err
}

// GetOAuthToken converts echo context to params.
func (w *ServerInterfaceWrapper) GetOAuthToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOAuthToken(ctx, accountId)
	return err
}

// GetRolesForAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetRolesForAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRolesForAccount(ctx, accountId)
	return err
}

// CreateRole converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRole(ctx, accountId)
	return err
}

// GetRole converts echo context to params.
func (w *ServerInterfaceWrapper) GetRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "roleId" -------------
	var roleId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "roleId", runtime.ParamLocationPath, ctx.Param("roleId"), &roleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter roleId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRole(ctx, accountId, roleId)
	return err
}

// UpdateRole converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "roleId" -------------
	var roleId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "roleId", runtime.ParamLocationPath, ctx.Param("roleId"), &roleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter roleId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateRole(ctx, accountId, roleId)
	return err
}

// GetOIDCConnectionsForAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetOIDCConnectionsForAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOIDCConnectionsForAccount(ctx, accountId)
	return err
}

// CreateOIDCCOnnection converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOIDCCOnnection(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateOIDCCOnnection(ctx, accountId)
	return err
}

// DeleteOIDCConnection converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteOIDCConnection(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "connectionId" -------------
	var connectionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, ctx.Param("connectionId"), &connectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connectionId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteOIDCConnection(ctx, accountId, connectionId)
	return err
}

// GetOIDCConnection converts echo context to params.
func (w *ServerInterfaceWrapper) GetOIDCConnection(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "connectionId" -------------
	var connectionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, ctx.Param("connectionId"), &connectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connectionId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOIDCConnection(ctx, accountId, connectionId)
	return err
}

// UpdateOIDCConnection converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateOIDCConnection(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "connectionId" -------------
	var connectionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, ctx.Param("connectionId"), &connectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connectionId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateOIDCConnection(ctx, accountId, connectionId)
	return err
}

// OIDCLoginTrigger converts echo context to params.
func (w *ServerInterfaceWrapper) OIDCLoginTrigger(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "connectionId" -------------
	var connectionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, ctx.Param("connectionId"), &connectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connectionId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.OIDCLoginTrigger(ctx, accountId, connectionId)
	return err
}

// OidcSSOCallBack converts echo context to params.
func (w *ServerInterfaceWrapper) OidcSSOCallBack(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "connectionId" -------------
	var connectionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, ctx.Param("connectionId"), &connectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connectionId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params OidcSSOCallBackParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// ------------- Required query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, true, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.OidcSSOCallBack(ctx, accountId, connectionId, params)
	return err
}

// GetSAMLConnectionsForAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetSAMLConnectionsForAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSAMLConnectionsForAccount(ctx, accountId)
	return err
}

// CreateSAMLConnection converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSAMLConnection(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSAMLConnection(ctx, accountId)
	return err
}

// GetSAMLConnection converts echo context to params.
func (w *ServerInterfaceWrapper) GetSAMLConnection(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "connectionId" -------------
	var connectionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, ctx.Param("connectionId"), &connectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connectionId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSAMLConnection(ctx, accountId, connectionId)
	return err
}

// UpdateSAMLConnection converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateSAMLConnection(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "connectionId" -------------
	var connectionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, ctx.Param("connectionId"), &connectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connectionId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateSAMLConnection(ctx, accountId, connectionId)
	return err
}

// SAMLLoginTrigger converts echo context to params.
func (w *ServerInterfaceWrapper) SAMLLoginTrigger(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "connectionId" -------------
	var connectionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, ctx.Param("connectionId"), &connectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connectionId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SAMLLoginTrigger(ctx, accountId, connectionId)
	return err
}

// CreateSAMLConnectionMapping converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSAMLConnectionMapping(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "connectionId" -------------
	var connectionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, ctx.Param("connectionId"), &connectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connectionId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSAMLConnectionMapping(ctx, accountId, connectionId)
	return err
}

// SamlSSOCallBack converts echo context to params.
func (w *ServerInterfaceWrapper) SamlSSOCallBack(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "connectionId" -------------
	var connectionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, ctx.Param("connectionId"), &connectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connectionId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SamlSSOCallBackParams
	// ------------- Optional query parameter "SAMLResponse" -------------

	err = runtime.BindQueryParameter("form", true, false, "SAMLResponse", ctx.QueryParams(), &params.SAMLResponse)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter SAMLResponse: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SamlSSOCallBack(ctx, accountId, connectionId, params)
	return err
}

// CreateTags converts echo context to params.
func (w *ServerInterfaceWrapper) CreateTags(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateTags(ctx, accountId)
	return err
}

// GetTagsForResource converts echo context to params.
func (w *ServerInterfaceWrapper) GetTagsForResource(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Path parameter "resourceId" -------------
	var resourceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "resourceId", runtime.ParamLocationPath, ctx.Param("resourceId"), &resourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter resourceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTagsForResource(ctx, accountId, serviceId, name, resourceId)
	return err
}

// GetUsersForAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsersForAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUsersForAccount(ctx, accountId)
	return err
}

// CreateUserForAccount converts echo context to params.
func (w *ServerInterfaceWrapper) CreateUserForAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateUserForAccount(ctx, accountId)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "userId", runtime.ParamLocationPath, ctx.Param("userId"), &userId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUser(ctx, accountId, userId)
	return err
}

// UpdateUser converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "userId", runtime.ParamLocationPath, ctx.Param("userId"), &userId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateUser(ctx, accountId, userId)
	return err
}

// ListServicesByDeveloper converts echo context to params.
func (w *ServerInterfaceWrapper) ListServicesByDeveloper(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListServicesByDeveloper(ctx)
	return err
}

// CreateService converts echo context to params.
func (w *ServerInterfaceWrapper) CreateService(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateService(ctx)
	return err
}

// GetDefaultService converts echo context to params.
func (w *ServerInterfaceWrapper) GetDefaultService(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDefaultService(ctx)
	return err
}

// DeleteService converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteService(ctx, serviceId)
	return err
}

// GetService converts echo context to params.
func (w *ServerInterfaceWrapper) GetService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetService(ctx, serviceId)
	return err
}

// UpdateService converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateService(ctx, serviceId)
	return err
}

// GetDeveloperPublicKeys converts echo context to params.
func (w *ServerInterfaceWrapper) GetDeveloperPublicKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDeveloperPublicKeys(ctx, serviceId)
	return err
}

// GetPasswordPolicy converts echo context to params.
func (w *ServerInterfaceWrapper) GetPasswordPolicy(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPasswordPolicy(ctx, serviceId)
	return err
}

// SetPassword converts echo context to params.
func (w *ServerInterfaceWrapper) SetPassword(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetPassword(ctx, serviceId)
	return err
}

// ServiceSignup converts echo context to params.
func (w *ServerInterfaceWrapper) ServiceSignup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ServiceSignup(ctx, serviceId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/arc/:serviceId/init", wrapper.InitArcClient)
	router.GET(baseURL+"/arc/:serviceId/role", wrapper.GetRolesForService)
	router.GET(baseURL+"/arc/:serviceId/tags", wrapper.GetTagsForService)
	router.POST(baseURL+"/assignrole", wrapper.AssignRoleToPrincipal)
	router.POST(baseURL+"/assumeRole", wrapper.AssumeRole)
	router.GET(baseURL+"/audit-logs/service/:serviceId/account/:accountId", wrapper.GetAuditLogs)
	router.GET(baseURL+"/confirmUser/:confirmationCode", wrapper.ConfirmUser)
	router.GET(baseURL+"/healthz", wrapper.GetHealthz)
	router.POST(baseURL+"/login-init/:serviceId", wrapper.LoginInit)
	router.POST(baseURL+"/login/:serviceId", wrapper.Login)
	router.GET(baseURL+"/org", wrapper.GetAccountOrganization)
	router.GET(baseURL+"/org/:accountId", wrapper.GetAccountInfo)
	router.DELETE(baseURL+"/org/:accountId/key/:keyId", wrapper.DeleteClientKey)
	router.GET(baseURL+"/org/:accountId/key/:keyId", wrapper.GetClientKey)
	router.GET(baseURL+"/org/:accountId/keys", wrapper.GetClientKeyList)
	router.POST(baseURL+"/org/:accountId/keys", wrapper.CreateClientKey)
	router.POST(baseURL+"/org/:accountId/oauth/token", wrapper.GetOAuthToken)
	router.GET(baseURL+"/org/:accountId/role", wrapper.GetRolesForAccount)
	router.POST(baseURL+"/org/:accountId/role", wrapper.CreateRole)
	router.GET(baseURL+"/org/:accountId/role/:roleId", wrapper.GetRole)
	router.PUT(baseURL+"/org/:accountId/role/:roleId", wrapper.UpdateRole)
	router.GET(baseURL+"/org/:accountId/sso-connections/oidc", wrapper.GetOIDCConnectionsForAccount)
	router.POST(baseURL+"/org/:accountId/sso-connections/oidc", wrapper.CreateOIDCCOnnection)
	router.DELETE(baseURL+"/org/:accountId/sso-connections/oidc/:connectionId", wrapper.DeleteOIDCConnection)
	router.GET(baseURL+"/org/:accountId/sso-connections/oidc/:connectionId", wrapper.GetOIDCConnection)
	router.PUT(baseURL+"/org/:accountId/sso-connections/oidc/:connectionId", wrapper.UpdateOIDCConnection)
	router.GET(baseURL+"/org/:accountId/sso-connections/oidc/:connectionId/login-trigger", wrapper.OIDCLoginTrigger)
	router.GET(baseURL+"/org/:accountId/sso-connections/oidc/:connectionId/sso-callback", wrapper.OidcSSOCallBack)
	router.GET(baseURL+"/org/:accountId/sso-connections/saml", wrapper.GetSAMLConnectionsForAccount)
	router.POST(baseURL+"/org/:accountId/sso-connections/saml", wrapper.CreateSAMLConnection)
	router.GET(baseURL+"/org/:accountId/sso-connections/saml/:connectionId", wrapper.GetSAMLConnection)
	router.PUT(baseURL+"/org/:accountId/sso-connections/saml/:connectionId", wrapper.UpdateSAMLConnection)
	router.GET(baseURL+"/org/:accountId/sso-connections/saml/:connectionId/login-trigger", wrapper.SAMLLoginTrigger)
	router.POST(baseURL+"/org/:accountId/sso-connections/saml/:connectionId/mapAttributeToRoles", wrapper.CreateSAMLConnectionMapping)
	router.POST(baseURL+"/org/:accountId/sso-connections/saml/:connectionId/sso-callback/saml/acs", wrapper.SamlSSOCallBack)
	router.POST(baseURL+"/org/:accountId/tags", wrapper.CreateTags)
	router.GET(baseURL+"/org/:accountId/tags/serviceId/:serviceId/name/:name/resource/:resourceId", wrapper.GetTagsForResource)
	router.GET(baseURL+"/org/:accountId/user", wrapper.GetUsersForAccount)
	router.POST(baseURL+"/org/:accountId/user", wrapper.CreateUserForAccount)
	router.GET(baseURL+"/org/:accountId/user/:userId", wrapper.GetUser)
	router.PUT(baseURL+"/org/:accountId/user/:userId", wrapper.UpdateUser)
	router.GET(baseURL+"/service", wrapper.ListServicesByDeveloper)
	router.POST(baseURL+"/service", wrapper.CreateService)
	router.GET(baseURL+"/service/3xA", wrapper.GetDefaultService)
	router.DELETE(baseURL+"/service/:serviceId", wrapper.DeleteService)
	router.GET(baseURL+"/service/:serviceId", wrapper.GetService)
	router.PUT(baseURL+"/service/:serviceId", wrapper.UpdateService)
	router.GET(baseURL+"/service/:serviceId/.well-known/jwks.json", wrapper.GetDeveloperPublicKeys)
	router.GET(baseURL+"/set-password/:serviceId", wrapper.GetPasswordPolicy)
	router.POST(baseURL+"/set-password/:serviceId", wrapper.SetPassword)
	router.POST(baseURL+"/sign-up/:serviceId", wrapper.ServiceSignup)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+w9XXPjNpJ/BaW7qmSqZGk2c7V155c7xc5mdfHGLsu+fdidB5hsSYhBgAFAa7RT/u9X",
	"+CJBCqQojy3Tk3lJxiIJNPob3Y3G51HCs5wzYEqOTj+PZLKGDJt/zqQkK3bNKVze/aZ/yAXPQSgC0v5F",
	"WEJyTOep/lNtcxidjqQShK1Gj+OR4BSij/Qz+L0gAtLR6T9q45RffXwc6/mLDF5xfqUEuSuUAeFvOM/1",
	"1ztgYP/WYUCMRw+YFrAfvGp8/0kdyCIl6oKvfmJKbCPQJQkvmGoBARdqDUyRBCvC2RlPQ3gIU7AC4d/j",
	"gvxrz2t6YvNKdLIcq3X8gSdA9KkE8UCSXpSsFht+5mYOwYuuPLbMEDiN7TNKgKlfYHt59xsk6lB8J/7z",
	"zue/4izOTETOEkUewod3nFPAzLOagQE+4SynoDFiGeVPJcv8UP7rw+jjeEQUZDI6lfsBC4G3e6kQIuYa",
	"fi9ARjCzZ20pLHFB1XVPoa2/XsPcxzo4MudMQhs8nYRYQCJAta1YAFawsHhpXTXOySKH5C+EGhBSkIkg",
	"uZURzZAM5wQ55KLfJGeIC7TFGUVL/cl4tOQiw0pTmjAstqNxDHXBoM05HIDoPPg1NgaROcVbT576GOf2",
	"IWI4A8SXSK3BwzzV1gOzLSokpIgw82xBVgwV+Rhd8BVh5n+8UAizFHG1BoEEUHjATKE7gVlK2ArleAUy",
	"ChhP5K2gu0DdrAHdXl+gJRdm0pQnRQZMaeFtABkbl/IV7zVuc6F6MS+2WhbFv6ehoc44qkAfcLLttRz3",
	"bg8MCUiJgERFh712D83YeKlAIIxkkSQg5bKgiGpcTGLDKhBZP4qaN/cC2lAMzOIorbF7KIX1hX0sx+NW",
	"oz+ORz8JwUVEYTi7VwfavIwSayxKYSVMffihgjWwkRlIiVetA/nH+5bpJvSva503Z0TNRNKu8eBTTnbs",
	"cwDafatduodtqy4cj34voABH0Yj5lpJwdsPvgbVoUg04wdSIT6sihQwTOktTAVJGkKefImwfe5ZJ4QGo",
	"HgM5q/yd1IIr9iK3NtfHHQjb8Csl/4nhOwppRIWC5mbCQCKyRFJyRCQC+7ZW+YyrCqzAqEvJr7vkcL4z",
	"mPZr0Bo/AFIcZfgeUIIp1X/oF4GlOSdMGSGrO0F70RKsTyPFYKOkax0Vyv9ch9Z8guw3+2azQ5QT/Z2o",
	"9RWWcsNF+jpMov1IO//u0B4yP2rbCPKe5J6eu6P8uEXOr7H6E20IpcirK0NCZwlEoH7HmqPUmkiUY4Ez",
	"zWiaHyQohCVSogDLE8Ixrh31Tg+iCsEgnUQ4r0siAkRo8lzOCrU2NN3j+z3d1wqnaJM+bGxPm54ZW+0H",
	"ct6i/Ay73Zif4yDMz8+uijtKkl8gts+iq116/gJbhOmKC6LWWYwdImbgejFD8MluyGOf3JMI+93DFpE0",
	"+rraxl83b8Y8kDhIGU8LWkR9lkJCfIqixZJpbN4rHN3U79+vlhu0n5wq62Cqp3HceJRwxiDRk7SMQKQs",
	"QHRCwDhL4lsdLlZxP1tjBXGxwswtEbEWj69rOzYeSYVbwhGGyzvB1pprzpa846WGbvDLCZDeQLHREsGy",
	"DiZ7mhE2s69EX6C4YMkaUucomyH7721Z256UkzQ5K1lBnjXmD7SH2Xt3PJc4o/1GksWdZom7py6m/F4c",
	"+KEmfDtgHZEWx6M1ImmKe5t4xSlJIiozI4xkRXYBK2YDQ7u7AfcKosBWau2Nq7c+fgOWmwmQWmOFtryw",
	"zo8ENUE32iqaoBlKMPtOaatHtfFXa8zQnyf9XHa38Au+AXGGY9puzuqAtUE0RgKWIKQ25Zs1mN1h+dzj",
	"1zgP5pVCAsIKUcBSIc4AUQ1CgqVehTJ23kxMRDn1JOpFuqEX2+yOU/l68EsDwIFQ3+b5a+O90CA8He/p",
	"r0XmBfJ1FsAMAP3Aboh6XUx317TDXRHCRWTIaIgWzWCxcMaZAhZxk+1nSBQUpN3HUMo3hK3Q7GqOcqzW",
	"coyI0iKvBT6FJWGQame4HmAzkj/ZuxGpQ6PhvuYU9tiwOsSzQF3uOhsmkJjOzEpDdfTn/4iqo7zE2r8L",
	"WI5OR/82rVI4U5e/mTrc1lIQDbeOU0BxkPQn8VCU+aiXV9Jg9PMeEaciTw/CxAMI2RLN0ERczP528RQn",
	"M5EXhN3Hn0VSQnU720WTaEIpYopxkRJgCbSCsdc/3RdNH49IeiX4A0lBxD0qvf9snT8DhVOscOsLgnN1",
	"e33xUgmdZvQ/WIyWzzIob/eK+3kgKq3I8qzfchsx5dFdfRBedGoiouoXH1AhqB6R58CQifvnkKDv/zdQ",
	"Su9M2B8lfpT4ZJHRL4jW9Eur/cwGUkKK7rYNkevvDh6qlTqTEEHyIUDptzzEYPMQnN1xLFInwg3zK0Cp",
	"LXKv6GEiYKIVMBCagzQT/oIVZpDxgSQvyuhZIehL2DH3KM7Ev+4y7zHSJM9rXRuB4UA1h2tvpmECrqpT",
	"KK5Cna6zGl29RPBXO8yTL4/0lqQwfyiuvU4vmctCFQImcTaRsiVnax4gwiyZnNqsphM80zZiSURmfzGx",
	"XW3rJoclNyogGkFdrUyK/LlwbWCUZMW0tijyprKYHJ6R8fB1RIP7mfcq/q/h05uofD841egalhu8koc6",
	"ma0xJwGSF6I9tNcd+PNPr9pqbZSDFacp0fjA9KoGdX8HYSdtqtpSfO3Kwm0kgjX7YRykGr23Rm99K7T4",
	"5uB8K7R45UKLHZm/lSAOUr43wDSB2iIIYYVbw/GSlf3D5h20BfXf0bAbkbM0IxEZJeEgDJmQdXyI4xXT",
	"xTlwfo42a5KsbWLXIRRVyQGkos70MdR7HeBb6/JEM/oum5S2fGW03PfGtL870OTq78+sA2Tcoyc5Ajb/",
	"bVnCY5ikpVTUEnEmIltD/x4HZrzHRwonhzbfNPCZJgduVMLxvdlzi7OMZccPV/R0J1Vr6LK8QPGab+qy",
	"MG4cH5Q1et0UNKhYMLrVd/DOahgZ2vFoPVI+mjCgBtDWbzGFbdmF+UJPU+Q5F+p/7t3+dJLwzLslpyO/",
	"a0UX+E6iOUs0gHrLeDpaK5XL0+kU52RS+7jpJYxszQCaXc0NZf2YE/R3otbln5UbKg2GcJoiB5whmYns",
	"jxEwBSIXRAJaLC7HKMPJmjBA97CVxg4uCYOTlcA24B1myzWJMsIKBdLgWav8y6VTN8GK5AavViAmhE/N",
	"O1P9MlG0hpATRFJgiqjteN+0GvqMpyAY+sfsan6yJEKqj0jypdpgAchae2KhKrecoz9N3k/eu5py7bqN",
	"TkcfzE+2mtsI1BSLZPq5JPfjlDBiyLuyaf2y3lvLhy+Ps5XBZhhXLCNHp//4PNLmwheKO/qHnmrFhUoU",
	"MHbHJGLe7kfjzxpRMFD+8P695z6XzcB5Tl3N1VR7otWxi96R5Gat344CN5zvwqQHTd81qy2MdEOHTF4w",
	"+JRDoiBF4N95HO8SSLjESZRAP4MJ6Mq/cLEofZCXotLYjfV7AcbXd4NRkhHNHDsfVqGPo9DXZJjeCFG9",
	"z9FGVL09/kZTOTVhgqHS1Bz18uKZcxlJu9rjYEi/pC03ZqURQNUhmXGD/tUZsht+Fbwl7D7+R55un23V",
	"9fNqkdWb5KVdamaNQJ25Hr+QDbqAMzulCEy3sio9Hb0yK4xHssgyLLZ9qe15xx3Ta+cde1hGImy3Cmij",
	"nR/HA5Ai4RN5O8zjR34xjglOGL4Cx0RKI+sA2J3VgPiiHyUtYxQpUSeUr+TUx3ZCu+GYfvq59OUfu8yI",
	"P+goj2BB6mOFe42DxmpsmBQWCiliQ3uUr7Q7L4iJT8XsltTv35AMvmzan1h6wKTA0oOnPIr1rJ9zjZjR",
	"cUtGPFzzgOTo2u3P6S6Ytqap3LXrDVZpILRcud21thzTz0kQBTnjKYQyVAfo/0CQ5dbu+11EVZosClpS",
	"vkHfJ5Qk94StXDiCEnb/boxKQUKEpRpFIN0QEt2Bft1BACa4MNlR4mcVtL0kt7mgo7LiPgsejTlFiH+z",
	"BmR2uhZXLsiF1lgjDVgjkoRRjoUiSUGxqJOd1aNQJK2GcAUag7INLuxjgmVlDOsOKGcr6UNmtQV5xKg1",
	"bF0C7qTIjVGZoFtZrx7QIzxYJg7CJS5EduLSikRJ9OHTrIZG/bv/O/iSs5OyhMGWRSaFVDzTz74P6qjf",
	"WbFbA6Zq/a8uG/VX98qRvIKoQvELteBa0E2S4IQwokIL3O6uXZTvozXQXIZYS/1JNnvsyAcq17ygKboD",
	"lAuQwDSLYLSY/e1iulhcog0X90bLGM2mv5iWNa+agCeEIc1awtS97SoRA9CckRcP3Dy/jxk73RgzV+bA",
	"lwmmeqGonyU73lYletoxquSINCW3RJbx3E7usIfaHgjWis0ssuKChGd3hLlaB+G/vp37b6tTcEGdhf73",
	"PLWCv1hcDkkXvroIVYJ/gMzbrd4W+Zh2meCI+gFe1Xh/gPLVSitTM06LEL89AW49ftotxXzpyHRU2Q0O",
	"5ca2s97pdLTWGzjCEK6SNzbfZ84oB0dV/XlSLXKi0Mw1Hn14/0NHttqoAnuUNccrMBIaHLU1eWybxa4l",
	"sdeAU3dQ4oInOF5pcXt9UZ7exXJtbLiZZdTFHY9DUw5tsma31C4nyNIyPWYlmotVq4fvyavdRktHM1RY",
	"RiZg5TwezMqkp00IEukVj98e+LTu7l7cflg70/eCTF2bJ4Lt8LnnDJxYGCdD3PQ9L4E8X7REUp6FRzq4",
	"YM6WvJdWf1oc5eNAGOsr4KMop0zvYTv9bHp/PFp2oWBPD9cJfm5+LxsrvSDF41E4253kmJyzdxu2qMqw",
	"DNac+rFnn9E9bAelfCxhEQ7g0+BFtcTPoLSXigmV9RXF9MAfiSe6CNNsDhch0c+glImZlQgNavkGxS3t",
	"HNCmRGSrzdFj+TgnpjQYTHby0wWRasCWpVfceocp+keuNarskd4B80gbXc1B1e5UIINNl2axLx5DubzQ",
	"xnGnJ+JjvZ7tpfeCu00Qu20YFytDu8kw840NdomqIY4LtZ6WpaqeA3dUTNVQ6O2x1W6/pSPzVaQbU4ep",
	"s1EGvf93xJufD1WfrUyIowEuSdEUSdvIJspzjaK2lu1WTVGa6nKXGLE4Qrk9wFym+tD8PGYbfYXcrNyW",
	"vWnr2Fbn1iRcT4QNcYv2FML3NJ6uMiZmNt2jN6baLDu0lOEobsqifeX9VirIjhpb7YJuuCbTQd2iuKaf",
	"bcXOY5fzrocSMV5zCuno+76yXmwYG782xhADY4yQlFrFFBFy29OWcXLbZ2+K4kfWUS4aZwogygIZd/B+",
	"MghlZWmYlskGC/Gg3DALonR8GtNcUvKTqgeOnHKSJge6YJfz8zMUjPEkb0wPErT1+3r8Mt+fs4drdjgi",
	"B++lPWlJfRy2xsAtvpvhqsvgpbe2QfXME2GW83mIAFT205JHVY5dEFacP0x/rslDvRWkqRUt24Y1cj3N",
	"fk36d5Nf2sey9tW6Ijy6d1Drh/YMyjSCDc2tAw1bdFCrLb9zDUoQeOhH4h1D9+bp+wdUIp0U794MaM2z",
	"j0fsm2+aTY5rCOv4HKAh9N0zB7gxwM9mBF1ltBJktbKdTKLq8sY+l3ZeWz1nD2kEhfvVwBPke0wl2N3F",
	"kRVUkZzCjm85QXNVFreWRfJ2itvrC5RwYamfOvezbc4dkdQz2XJAt7qepy+eJkLjF9ziDIX/Sjbg9wq7",
	"gwfm8MzT+c+8gym9w8l9K/v9FbOUQo37ym92qE7SZLG4PMOU/mifvxEdvHNwbVbrI5HwtLqxxDc2NQjJ",
	"fevX+Im25NAzRC8FiL2V4Uvk4PVKbmtdqPgS0aC/Vm3o+thvoxrXipel4WJx2ZSwXrItcUYPjEBpA/vF",
	"ESg9yFcZgQrcj30RqMMROfgI1JOW1CcC1Ri4JQJV56q3F4EqmWcvs7yW470HwkFHoJo81FtBRiJQrdEJ",
	"IA/gjj/tiU0cjVnfUGzibbFXB733Ryb2cYhrH/uWmeSbgnw7kYnnUo6HRibMvF8UmWj6HC8XmdAzfYtM",
	"vEhkwhBRb2IOjk7EeDDDeXlnzQ2/9j1x+ziapdpAmb3oxrHlUxxQf1XOH11rx+8PalHhtslxqby1gJpm",
	"XlmJzG/KvI+325eRnyxkYQjQvoCTDjFz0YpA3/uP7SFA8wBLCcIq/Hl5EVqufzX3oJnIVHBdMBcox1vK",
	"cRpR1jijX0dA0WCmPOneDOGZp/Pzq5bonX5clrs/i+x/OtlsNidLLrKTQlBgCU/tzeHV2PVW1jUQTp+8",
	"ur1t3d1xgm+BxyMFHl9MlKMqybdrjWuXpNR9/lIOC0oZcjKfx432De7ZnG9QsSLbljXS3QavbE/tEhEk",
	"ParRbANsqB1D+7FOK09Oy6YvtS6RmmWmn/V/H6d+3Onn6saYPYXremRflYul5Akx1a8GMK0X/UCxwJJr",
	"XHxdvXJcy/ecPSzLm3a+sAw7vKlnGKGuNjFRrt3yoIrvDTtq+1jyXVQeCtmx5Y9nDOxB4aekkLQ++YoS",
	"R7bR8v6sUU+EDT5V1H8dfbbt1riwFCkfUfCt2mzrRbfishvZGC05pXxjPU0J6qRsVxR3EvQEx2O253cX",
	"Ovt4Bw1YBtNcfLg769CRQYoEt+rkkJCl/oHXG/S0qMrpZ3vPUGf/6N4NaJ/ThLv7j4bUwrZNFw5eFe5P",
	"BdU843geqDcXPIFy42/a66vWXhWjFdLdgus3La3Omunl4l6S9lyglbOdhEkZMZmga4t6bdWx8Ner1e9V",
	"2m2uSaRyV6zIH7fnfrDRUWp1du9b79vmRnswJXpqGghXGBlUX9eXIugeBw1h5O8GJCy4RuySJRA0iyfS",
	"Nwav2mbnfKMdOUGSdXiDWHmfh+k0Xq9xxDm+I5QoAhJxhu5gjelSe5wLjBfo+9nV/B0qeawtHlTd+NOu",
	"ymz2EQs1NYHQFCt8QIObcJqOrqznro8VvuOFQmrtsTVGhCW08A3AkYJP6kSAa7JYayc5u5ojWYgl1tgW",
	"gI+bPonIVyST4lig6uhDt8iiKB1gS5+AocszyIFGnX74NOsO7ZT8PZvNGseZY9vcc7v6kClflVzecgy0",
	"55uVFY/j76TBspH+siV0SQAirY6pt+u3VwPyQtT68RcS3KWUOAOUcNFfERlluwHEl0sQoSaqWmvXWajR",
	"93rvacdqab9yBbbBsG2aWHKTXitG/xxJvlT/HPnHmzUI0GsP9yvmJsfvlHZIQUq01ZgoJ+hhESYtZy1f",
	"/iK1/qciq0YCwzwRWe+pLMvLdYdC4Y7+mzV+vLEXSttrt9xQWSFV0C3e9wR209nsmsn6u5N/tatgnZiP",
	"UcGohr12TaxEubm1NFpt+Vrc94dXzR3svK+by+IApmwroDwO3V/ET6ytoMNPrPsjjQvRX7OZSz+2fTOt",
	"XSrXr+fWqMWoTycboPTknvENm/62uZcTv4p2pWo1m+m8a/yJxn3U7n6h3za+EyCRsqj7Ne5Ca70jSDlI",
	"xLhCjhX8IroFyjijzmOx10P/YjvhDlWj1stQfKvffo1k5udn5RojUYFI8UlbO9yKcrJeYjI4PX18HmPm",
	"xo4d++0Ep0rKNF3ijsT5GsqbJ1DOKUm26HsKbKXWY5SsscCJsneSq+TdWC9rDTQPbrMBe1WPqRJOqkve",
	"Y9LgL1a5MtO8UdeisYhYO7jgSv7q6h4lYMXUGjGA1N2JXxU0hdfjR/PJL0Wl1mjUIoBIS6UtMzWFWA8g",
	"liQh1b3vLo+TVHuEneLCivhv72KgAPhOpyJAGLF3ZfTyHHaGsf10c2yH0gj2Fy8NtDFNbemWRwzEYSbZ",
	"R33Iip0Ueb+rqi7ZHRc4Da7ra8Zew0AFyjDDq6Z+/RmYZkSQXdltWwBWFjY1bmPUFDDC48Aob3V0EWyl",
	"VfjuzY4RITC/L8xlnG9QDAzcXRJgbxmdu1ux6ttQXyZau/K0unzxuG62W0lHt3S7lOGK3JeLhp1Uv+AZ",
	"sBB0dDpaK5WfTqeUJ5iuuVSn//n+v96PHj8+/n8AAAD//wVfKwpCtAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
