// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// AssignRoleObj defines model for AssignRoleObj.
type AssignRoleObj struct {
	AccountId *string `json:"accountId,omitempty"`
	RoleId    *string `json:"roleId,omitempty"`
	UserId    string  `json:"userId"`
}

// AttributeRoleMapping defines model for AttributeRoleMapping.
type AttributeRoleMapping struct {
	Attribute string `dynamodbav:"attribute" json:"attribute"`
	RoleId    string `dynamodbav:"roleId" json:"roleId"`
	Value     string `dynamodbav:"value" json:"value"`
}

// ClientKeyObject defines model for ClientKeyObject.
type ClientKeyObject struct {
	AccountId   *string   `dynamodbav:"accountId" json:"accountId,omitempty"`
	ClientKeyId *string   `dynamodbav:"clientKeyId" json:"clientKeyId,omitempty"`
	ClientName  *string   `dynamodbav:"clientName" json:"clientName,omitempty"`
	IsActive    *bool     `dynamodbav:"isActive" json:"isActive,omitempty"`
	Roles       *[]string `dynamodbav:"roles" json:"roles,omitempty"`
	ServiceId   *string   `dynamodbav:"serviceId" json:"serviceId,omitempty"`
}

// ClientKeyRequest defines model for ClientKeyRequest.
type ClientKeyRequest struct {
	ClientName    string `json:"clientName"`
	DefaultRoleId string `json:"defaultRoleId"`
}

// ClientKeyResponse defines model for ClientKeyResponse.
type ClientKeyResponse struct {
	ClientId     *string `json:"clientId,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty"`
}

// Developer defines model for Developer.
type Developer struct {
	// AccountId account ID
	AccountId *string `dynamodbav:"accountId, hash" json:"accountId,omitempty"`

	// Admin admin email address of creator [rename this to creator]
	Admin     *string `dynamodbav:"email" json:"admin,omitempty"`
	CreatedAt *int64  `dynamodbav:"createdAt" json:"createdAt,omitempty"`

	// Developer Developer name
	Developer *string `dynamodbav:"developer" json:"developer,omitempty"`

	// IsActive Is the Developer active yet?
	IsActive           *bool     `dynamodbav:"isactive" json:"isActive,omitempty"`
	LaunchedServices   *[]string `dynamodbav:"launchedServices" json:"launchedServices,omitempty"`
	SubscribedServices *[]string `dynamodbav:"subscribedServices" json:"subscribedServices,omitempty"`
	UpdatedAt          *int64    `dynamodbav:"updatedAt" json:"updatedAt,omitempty"`

	// UserPool Cognito User Pool ID
	UserPool *string `dynamodbav:"userPool" json:"userPool,omitempty"`

	// UserPoolClient Cognito User Pool Client ID
	UserPoolClient *string `dynamodbav:"userPoolClient" json:"userPoolClient,omitempty"`
	Version        *int    `dynamodbav:"version" json:"version,omitempty"`
}

// Error defines model for Error.
type Error struct {
	// Code Error code
	Code int32 `json:"code"`

	// Message Error message
	Message string `json:"message"`
}

// LoginUserObj defines model for LoginUserObj.
type LoginUserObj struct {
	AccountId *string `json:"accountId,omitempty"`
	Password  *string `json:"password,omitempty"`
	ServiceId *string `json:"serviceId,omitempty"`
	UserId    string  `json:"userId"`
}

// OAuthTokenRequest defines model for OAuthTokenRequest.
type OAuthTokenRequest struct {
	ClientId     *string `json:"clientId,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty"`
}

// OAuthTokenResponse defines model for OAuthTokenResponse.
type OAuthTokenResponse struct {
	AccessToken *string `json:"accessToken,omitempty"`
	ExpiresIn   *int    `json:"expiresIn,omitempty"`
	TokenType   *string `json:"tokenType,omitempty"`
}

// OIDCPublicKey defines model for OIDCPublicKey.
type OIDCPublicKey struct {
	// Alg Key algorithm
	Alg *string `json:"alg,omitempty"`

	// E RSA exponent
	E *string `json:"e,omitempty"`

	// Kid key id
	Kid *string `json:"kid,omitempty"`

	// Kty key type
	Kty *string `json:"kty,omitempty"`

	// N RSA moduluses
	N *string `json:"n,omitempty"`

	// Use key usage
	Use *string `json:"use,omitempty"`
}

// OktaObj defines model for OktaObj.
type OktaObj struct {
	AccountId             *string `dynamodbav:"accountId" json:"accountId,omitempty"`
	AuthorizationEndpoint *string `json:"authorizationEndpoint,omitempty"`
	ClientId              string  `dynamodbav:"clientId" json:"clientId"`
	ClientSecret          string  `dynamodbav:"clientSecret" json:"clientSecret"`
	ConnectionId          *string `dynamodbav:"connectionId, hash" json:"connectionId,omitempty"`
	IssuerEndpoint        *string `json:"issuerEndpoint,omitempty"`
	Nonce                 *string `dynamodbav:"nonce" json:"nonce,omitempty"`

	// OrgName Okta organization name
	OrgName          string  `dynamodbav:"orgName" json:"orgName"`
	ServiceId        *string `dynamodbav:"serviceId" json:"serviceId,omitempty"`
	State            *string `dynamodbav:"state" json:"state,omitempty"`
	TokenEndpoint    *string `json:"tokenEndpoint,omitempty"`
	UserInfoEndpoint *string `json:"userInfoEndpoint,omitempty"`
}

// Organization defines model for Organization.
type Organization struct {
	AccountId            string    `json:"accountId"`
	AdminAccount         string    `json:"adminAccount"`
	LaunchedServices     *[]string `json:"launchedServices,omitempty"`
	Name                 string    `json:"name"`
	OidcConnectionsCount *int      `json:"oidcConnectionsCount,omitempty"`
	RolesCount           *int      `json:"rolesCount,omitempty"`
	SamlConnectionsCount *int      `json:"samlConnectionsCount,omitempty"`
	SubscribedServices   *[]string `json:"subscribedServices,omitempty"`
	Subscribers          *[]string `json:"subscribers,omitempty"`
	UsersCount           *int      `json:"usersCount,omitempty"`
}

// Policy defines model for Policy.
type Policy struct {
	Allow *[]string `dynamodbav:"allow" json:"allow,omitempty"`

	// Where Where clause
	Where *string `dynamodbav:"where" json:"where,omitempty"`
}

// Role defines model for Role.
type Role struct {
	// AccountId AccountId
	AccountId *string   `dynamodbav:"accountId" json:"accountId,omitempty"`
	CreatedAt *int64    `dynamodbav:"createdAt" json:"createdAt,omitempty"`
	Policies  *[]Policy `dynamodbav:"policies" json:"policies,omitempty"`

	// PolicyContent policy content blob either in json or yaml format (look in apispec for format of this blob.)
	PolicyContent *string `json:"policyContent,omitempty"`

	// PolicyType policy type, e.g. "default", "open api 3.1", "graph ql etc"
	PolicyType    *string `dynamodbav:"policyType" json:"policyType,omitempty"`
	PolicyVersion *int    `dynamodbav:"policyVersion" json:"policyVersion,omitempty"`

	// RoleId Role Id
	RoleId *string `dynamodbav:"roleId,hash" json:"roleId,omitempty"`

	// Rolename Role name
	Rolename *string `dynamodbav:"rolename" json:"rolename,omitempty"`

	// ServiceId ID of the service
	ServiceId *string `dynamodbav:"serviceId" json:"serviceId,omitempty"`
	UpdatedAt *int64  `dynamodbav:"updatedAt" json:"updatedAt,omitempty"`
	Version   *int    `dynamodbav:"version" json:"version,omitempty"`
}

// SAMLObj defines model for SAMLObj.
type SAMLObj struct {
	AccountId             string                  `dynamodbav:"accountId" json:"accountId"`
	AcsLink               *string                 `dynamodbav:"acsLink" json:"acsLink,omitempty"`
	AttributeRoleMappings *[]AttributeRoleMapping `dynamodbav:"attributeRoleMappings" json:"attributeRoleMappings,omitempty"`
	AudienceLink          *string                 `dynamodbav:"audienceLink" json:"audienceLink,omitempty"`
	ConnectionId          *string                 `dynamodbav:"connectionId, hash" json:"connectionId,omitempty"`
	DefaultRoleId         string                  `dynamodbav:"defaultRoleId" json:"defaultRoleId"`
	IdProvider            string                  `dynamodbav:"idProvider" json:"idProvider"`
	LoginLink             *string                 `dynamodbav:"loginLink" json:"loginLink,omitempty"`
	MetadataLink          *string                 `dynamodbav:"metadataLink" json:"metadataLink,omitempty"`
	RootURL               *string                 `dynamodbav:"rootURL" json:"rootURL,omitempty"`
	ServiceId             string                  `dynamodbav:"serviceId" json:"serviceId"`
}

// Service defines model for Service.
type Service struct {
	// AccountId Account ID
	AccountId *string `dynamodbav:"accountId" json:"accountId,omitempty"`

	// Apis List of paths exposed by the service
	Apis      *[]string `dynamodbav:"apiPaths" json:"apis,omitempty"`
	CreatedAt *int64    `dynamodbav:"createdAt" json:"createdAt,omitempty"`

	// Description Description of service
	Description *string `dynamodbav:"description" json:"description,omitempty"`

	// DisplayName Display name of the service/company used in the Sign up, Login, Logout and other relevant branding pages
	DisplayName *string `dynamodbav:"displayName" json:"displayName,omitempty"`

	// DocumentationUrl The URL for the documentatio of the service
	DocumentationUrl *string `dynamodbav:"docsUrl" json:"documentationUrl,omitempty"`

	// KeyId key id to sign jwt tokens
	KeyId *string `json:"keyId,omitempty"`

	// LogoUrl The URL for the service/company Logo used in the Sign up, Login, Logout and other relevant branding pages
	LogoUrl *string `dynamodbav:"logoUrl" json:"logoUrl,omitempty"`

	// OnboardURL Pretty onboarding URL for the service
	OnboardURL *string `dynamodbav:"onboardURL" json:"onboardURL,omitempty"`

	// PrivacyUrl The URL for the privacy of the service
	PrivacyUrl *string `dynamodbav:"privacyUrl" json:"privacyUrl,omitempty"`

	// RedirectURL Redirect URL where subscriber is redirected upon successful authenticatio
	RedirectURL *string `dynamodbav:"redirectURL" json:"redirectURL,omitempty"`

	// ServiceId ID of the service
	ServiceId *string `dynamodbav:"serviceId, hash" json:"serviceId,omitempty"`

	// Servicename Name of the service
	Servicename *string `dynamodbav:"serviceName" json:"servicename,omitempty"`

	// TermsofServiceUrl The URL for the terms of the service
	TermsofServiceUrl *string `dynamodbav:"termsUrl" json:"termsofServiceUrl,omitempty"`
	UpdatedAt         *int64  `dynamodbav:"updatedAt" json:"updatedAt,omitempty"`
	Version           *int    `dynamodbav:"version" json:"version,omitempty"`
}

// Tags defines model for Tags.
type Tags struct {
	AccountId     *string             `dynamodbav:"accountId" json:"accountId,omitempty"`
	CreatedAt     *int64              `dynamodbav:"createdAt" json:"createdAt,omitempty"`
	Name          string              `dynamodbav:"name" json:"name"`
	ResourceId    string              `dynamodbav:"resourceId, hash" json:"resourceId"`
	ServiceId     string              `dynamodbav:"serviceId" json:"serviceId"`
	ServiceIdPath *string             `dynamodbav:"serviceIdPath, hash" json:"serviceIdPath,omitempty"`
	Tags          map[string][]string `dynamodbav:"tags" json:"tags"`
	Token         string              `json:"token"`
	UpdatedAt     *int64              `dynamodbav:"updatedAt" json:"updatedAt,omitempty"`
	Version       *int                `dynamodbav:"version" json:"version,omitempty"`
}

// User defines model for User.
type User struct {
	// AccountId Tenant name
	AccountId string `dynamodbav:"accountId, hash" json:"accountId"`

	// IsActive Is the user active yet?
	IsActive *bool `dynamodbav:"isactive" json:"isActive,omitempty"`

	// IsAdmin is the user an admin?
	IsAdmin *bool     `dynamodbav:"isAdmin" json:"isAdmin,omitempty"`
	Roles   *[]string `dynamodbav:"roles" json:"roles,omitempty"`

	// ServiceId Service ID
	ServiceId *string              `dynamodbav:"serviceId, hash" json:"serviceId,omitempty"`
	Tags      *map[string][]string `dynamodbav:"tags" json:"tags,omitempty"`

	// Token User token
	Token *string `dynamodbav:"token" json:"token,omitempty"`

	// UserId User name (email)
	UserId *string `dynamodbav:"userId,hash" json:"userId,omitempty"`
}

// UserConfirmation defines model for UserConfirmation.
type UserConfirmation struct {
	// AccountId AccountId
	AccountId string `json:"accountId"`

	// ConfirmationCode confirmation code sent
	ConfirmationCode *string `json:"confirmationCode,omitempty"`

	// NewPassword New password
	NewPassword *string `json:"newPassword,omitempty"`

	// Session session
	Session *string `json:"session,omitempty"`

	// UserId User id
	UserId string `json:"userId"`
}

// CreateClientKeyJSONRequestBody defines body for CreateClientKey for application/json ContentType.
type CreateClientKeyJSONRequestBody = ClientKeyRequest

// CreateOKTAConnectionJSONRequestBody defines body for CreateOKTAConnection for application/json ContentType.
type CreateOKTAConnectionJSONRequestBody = OktaObj

// CreateSAMLConnectionJSONRequestBody defines body for CreateSAMLConnection for application/json ContentType.
type CreateSAMLConnectionJSONRequestBody = SAMLObj

// UpdateSAMLConnectionJSONRequestBody defines body for UpdateSAMLConnection for application/json ContentType.
type UpdateSAMLConnectionJSONRequestBody = SAMLObj

// CreateSAMLConnectionMappingJSONRequestBody defines body for CreateSAMLConnectionMapping for application/json ContentType.
type CreateSAMLConnectionMappingJSONRequestBody = AttributeRoleMapping

// CreateDeveloperJSONRequestBody defines body for CreateDeveloper for application/json ContentType.
type CreateDeveloperJSONRequestBody = Developer

// GetOAuthTokenJSONRequestBody defines body for GetOAuthToken for application/json ContentType.
type GetOAuthTokenJSONRequestBody = OAuthTokenRequest

// CreateRoleJSONRequestBody defines body for CreateRole for application/json ContentType.
type CreateRoleJSONRequestBody = Role

// CreateServiceJSONRequestBody defines body for CreateService for application/json ContentType.
type CreateServiceJSONRequestBody = Service

// CreateTagsJSONRequestBody defines body for CreateTags for application/json ContentType.
type CreateTagsJSONRequestBody = Tags

// CreateUserForDeveloperJSONRequestBody defines body for CreateUserForDeveloper for application/json ContentType.
type CreateUserForDeveloperJSONRequestBody = User

// AssignRoleToUserJSONRequestBody defines body for AssignRoleToUser for application/json ContentType.
type AssignRoleToUserJSONRequestBody = AssignRoleObj

// ConfirmUserJSONRequestBody defines body for ConfirmUser for application/json ContentType.
type ConfirmUserJSONRequestBody = UserConfirmation

// LoginUserJSONRequestBody defines body for LoginUser for application/json ContentType.
type LoginUserJSONRequestBody = LoginUserObj

// SetUserPasswordJSONRequestBody defines body for SetUserPassword for application/json ContentType.
type SetUserPasswordJSONRequestBody = UserConfirmation

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = User

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetClientKeyList request
	GetClientKeyList(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientKey request with any body
	CreateClientKeyWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClientKey(ctx context.Context, accountId string, body CreateClientKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClientKey request
	DeleteClientKey(ctx context.Context, accountId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientKey request
	GetClientKey(ctx context.Context, accountId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOKTAConnection request with any body
	CreateOKTAConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOKTAConnection(ctx context.Context, body CreateOKTAConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOKTAConnection request
	GetOKTAConnection(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSAMLConnection request with any body
	CreateSAMLConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSAMLConnection(ctx context.Context, body CreateSAMLConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSAMLConnection request with any body
	UpdateSAMLConnectionWithBody(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSAMLConnection(ctx context.Context, connectionId string, body UpdateSAMLConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSAMLConnectionMapping request with any body
	CreateSAMLConnectionMappingWithBody(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSAMLConnectionMapping(ctx context.Context, connectionId string, body CreateSAMLConnectionMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDeveloper request with any body
	CreateDeveloperWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDeveloper(ctx context.Context, serviceId string, body CreateDeveloperJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeveloperByServiceAndEmail request
	GetDeveloperByServiceAndEmail(ctx context.Context, serviceId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeveloper request
	GetDeveloper(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHealthz request
	GetHealthz(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOAuthToken request with any body
	GetOAuthTokenWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetOAuthToken(ctx context.Context, accountId string, body GetOAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOwnAccountInfo request
	GetOwnAccountInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccountInfo request
	GetAccountInfo(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOIDCConnectionsForAccount request
	GetOIDCConnectionsForAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSAMLConnectionsForAccount request
	GetSAMLConnectionsForAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRolesForAccount request
	GetRolesForAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRole request
	GetRole(ctx context.Context, accountId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersForAccount request
	GetUsersForAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, accountId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRole request with any body
	CreateRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRole(ctx context.Context, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssumeRole request
	AssumeRole(ctx context.Context, accountId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateService request with any body
	CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateService(ctx context.Context, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultService request
	GetDefaultService(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddSpecForService request with any body
	AddSpecForServiceWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetService request
	GetService(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTags request with any body
	CreateTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTags(ctx context.Context, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTagsForResource request
	GetTagsForResource(ctx context.Context, serviceId string, accountId string, name string, resourceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserForDeveloper request with any body
	CreateUserForDeveloperWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserForDeveloper(ctx context.Context, body CreateUserForDeveloperJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignRoleToUser request with any body
	AssignRoleToUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssignRoleToUser(ctx context.Context, body AssignRoleToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfirmUser request with any body
	ConfirmUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConfirmUser(ctx context.Context, body ConfirmUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginUser request with any body
	LoginUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LoginUser(ctx context.Context, body LoginUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OktaAuthorizeHandler request
	OktaAuthorizeHandler(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OktaSAMLAuthorizeHandler request
	OktaSAMLAuthorizeHandler(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OktaLoginHandler request
	OktaLoginHandler(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OktaSAMLLoginHandler request
	OktaSAMLLoginHandler(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetUserPassword request with any body
	SetUserPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetUserPassword(ctx context.Context, body SetUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserWithoutDeveloper request
	GetUserWithoutDeveloper(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUser request with any body
	UpdateUserWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicePublicKeys request
	GetServicePublicKeys(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetClientKeyList(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientKeyListRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientKeyWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientKeyRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientKey(ctx context.Context, accountId string, body CreateClientKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientKeyRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClientKey(ctx context.Context, accountId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClientKeyRequest(c.Server, accountId, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientKey(ctx context.Context, accountId string, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientKeyRequest(c.Server, accountId, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOKTAConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOKTAConnectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOKTAConnection(ctx context.Context, body CreateOKTAConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOKTAConnectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOKTAConnection(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOKTAConnectionRequest(c.Server, connectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSAMLConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSAMLConnectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSAMLConnection(ctx context.Context, body CreateSAMLConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSAMLConnectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSAMLConnectionWithBody(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSAMLConnectionRequestWithBody(c.Server, connectionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSAMLConnection(ctx context.Context, connectionId string, body UpdateSAMLConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSAMLConnectionRequest(c.Server, connectionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSAMLConnectionMappingWithBody(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSAMLConnectionMappingRequestWithBody(c.Server, connectionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSAMLConnectionMapping(ctx context.Context, connectionId string, body CreateSAMLConnectionMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSAMLConnectionMappingRequest(c.Server, connectionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeveloperWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeveloperRequestWithBody(c.Server, serviceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeveloper(ctx context.Context, serviceId string, body CreateDeveloperJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeveloperRequest(c.Server, serviceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeveloperByServiceAndEmail(ctx context.Context, serviceId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeveloperByServiceAndEmailRequest(c.Server, serviceId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeveloper(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeveloperRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHealthz(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHealthzRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthTokenWithBody(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthTokenRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthToken(ctx context.Context, accountId string, body GetOAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthTokenRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOwnAccountInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOwnAccountInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountInfo(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountInfoRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOIDCConnectionsForAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOIDCConnectionsForAccountRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSAMLConnectionsForAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSAMLConnectionsForAccountRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRolesForAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolesForAccountRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRole(ctx context.Context, accountId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleRequest(c.Server, accountId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersForAccount(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersForAccountRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, accountId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, accountId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRole(ctx context.Context, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssumeRole(ctx context.Context, accountId string, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssumeRoleRequest(c.Server, accountId, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateService(ctx context.Context, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultService(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultServiceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddSpecForServiceWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddSpecForServiceRequestWithBody(c.Server, serviceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetService(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTags(ctx context.Context, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTagsForResource(ctx context.Context, serviceId string, accountId string, name string, resourceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsForResourceRequest(c.Server, serviceId, accountId, name, resourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserForDeveloperWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserForDeveloperRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserForDeveloper(ctx context.Context, body CreateUserForDeveloperJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserForDeveloperRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignRoleToUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignRoleToUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignRoleToUser(ctx context.Context, body AssignRoleToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignRoleToUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmUser(ctx context.Context, body ConfirmUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginUser(ctx context.Context, body LoginUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OktaAuthorizeHandler(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOktaAuthorizeHandlerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OktaSAMLAuthorizeHandler(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOktaSAMLAuthorizeHandlerRequest(c.Server, connectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OktaLoginHandler(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOktaLoginHandlerRequest(c.Server, connectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OktaSAMLLoginHandler(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOktaSAMLLoginHandlerRequest(c.Server, connectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetUserPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetUserPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetUserPassword(ctx context.Context, body SetUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetUserPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserWithoutDeveloper(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserWithoutDeveloperRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicePublicKeys(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicePublicKeysRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetClientKeyListRequest generates requests for GetClientKeyList
func NewGetClientKeyListRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clientkey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClientKeyRequest calls the generic CreateClientKey builder with application/json body
func NewCreateClientKeyRequest(server string, accountId string, body CreateClientKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientKeyRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewCreateClientKeyRequestWithBody generates requests for CreateClientKey with any type of body
func NewCreateClientKeyRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clientkey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClientKeyRequest generates requests for DeleteClientKey
func NewDeleteClientKeyRequest(server string, accountId string, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clientkey/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientKeyRequest generates requests for GetClientKey
func NewGetClientKeyRequest(server string, accountId string, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clientId", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clientkey/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOKTAConnectionRequest calls the generic CreateOKTAConnection builder with application/json body
func NewCreateOKTAConnectionRequest(server string, body CreateOKTAConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOKTAConnectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateOKTAConnectionRequestWithBody generates requests for CreateOKTAConnection with any type of body
func NewCreateOKTAConnectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections/okta")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOKTAConnectionRequest generates requests for GetOKTAConnection
func NewGetOKTAConnectionRequest(server string, connectionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections/okta/connection/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSAMLConnectionRequest calls the generic CreateSAMLConnection builder with application/json body
func NewCreateSAMLConnectionRequest(server string, body CreateSAMLConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSAMLConnectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSAMLConnectionRequestWithBody generates requests for CreateSAMLConnection with any type of body
func NewCreateSAMLConnectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections/saml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateSAMLConnectionRequest calls the generic UpdateSAMLConnection builder with application/json body
func NewUpdateSAMLConnectionRequest(server string, connectionId string, body UpdateSAMLConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSAMLConnectionRequestWithBody(server, connectionId, "application/json", bodyReader)
}

// NewUpdateSAMLConnectionRequestWithBody generates requests for UpdateSAMLConnection with any type of body
func NewUpdateSAMLConnectionRequestWithBody(server string, connectionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections/saml/connection/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSAMLConnectionMappingRequest calls the generic CreateSAMLConnectionMapping builder with application/json body
func NewCreateSAMLConnectionMappingRequest(server string, connectionId string, body CreateSAMLConnectionMappingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSAMLConnectionMappingRequestWithBody(server, connectionId, "application/json", bodyReader)
}

// NewCreateSAMLConnectionMappingRequestWithBody generates requests for CreateSAMLConnectionMapping with any type of body
func NewCreateSAMLConnectionMappingRequestWithBody(server string, connectionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections/saml/mapping/connection/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDeveloperRequest calls the generic CreateDeveloper builder with application/json body
func NewCreateDeveloperRequest(server string, serviceId string, body CreateDeveloperJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDeveloperRequestWithBody(server, serviceId, "application/json", bodyReader)
}

// NewCreateDeveloperRequestWithBody generates requests for CreateDeveloper with any type of body
func NewCreateDeveloperRequestWithBody(server string, serviceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/developer/service/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDeveloperByServiceAndEmailRequest generates requests for GetDeveloperByServiceAndEmail
func NewGetDeveloperByServiceAndEmailRequest(server string, serviceId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/developer/service/%s/user/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeveloperRequest generates requests for GetDeveloper
func NewGetDeveloperRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/developer/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHealthzRequest generates requests for GetHealthz
func NewGetHealthzRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/healthz")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOAuthTokenRequest calls the generic GetOAuthToken builder with application/json body
func NewGetOAuthTokenRequest(server string, accountId string, body GetOAuthTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetOAuthTokenRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewGetOAuthTokenRequestWithBody generates requests for GetOAuthToken with any type of body
func NewGetOAuthTokenRequestWithBody(server string, accountId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/%s/token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOwnAccountInfoRequest generates requests for GetOwnAccountInfo
func NewGetOwnAccountInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccountInfoRequest generates requests for GetAccountInfo
func NewGetAccountInfoRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOIDCConnectionsForAccountRequest generates requests for GetOIDCConnectionsForAccount
func NewGetOIDCConnectionsForAccountRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/connections/oidc", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSAMLConnectionsForAccountRequest generates requests for GetSAMLConnectionsForAccount
func NewGetSAMLConnectionsForAccountRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/connections/saml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRolesForAccountRequest generates requests for GetRolesForAccount
func NewGetRolesForAccountRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/role", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoleRequest generates requests for GetRole
func NewGetRoleRequest(server string, accountId string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/role/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersForAccountRequest generates requests for GetUsersForAccount
func NewGetUsersForAccountRequest(server string, accountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/user", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, accountId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/%s/user/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRoleRequest calls the generic CreateRole builder with application/json body
func NewCreateRoleRequest(server string, body CreateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRoleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRoleRequestWithBody generates requests for CreateRole with any type of body
func NewCreateRoleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/role")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssumeRoleRequest generates requests for AssumeRole
func NewAssumeRoleRequest(server string, accountId string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/role/assume/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServiceRequest calls the generic CreateService builder with application/json body
func NewCreateServiceRequest(server string, body CreateServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateServiceRequestWithBody generates requests for CreateService with any type of body
func NewCreateServiceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDefaultServiceRequest generates requests for GetDefaultService
func NewGetDefaultServiceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/default")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddSpecForServiceRequestWithBody generates requests for AddSpecForService with any type of body
func NewAddSpecForServiceRequestWithBody(server string, serviceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/openapi/service/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServiceRequest generates requests for GetService
func NewGetServiceRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTagsRequest calls the generic CreateTags builder with application/json body
func NewCreateTagsRequest(server string, body CreateTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTagsRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTagsRequestWithBody generates requests for CreateTags with any type of body
func NewCreateTagsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTagsForResourceRequest generates requests for GetTagsForResource
func NewGetTagsForResourceRequest(server string, serviceId string, accountId string, name string, resourceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "resourceId", runtime.ParamLocationPath, resourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/service/%s/developer/%s/name/%s/resource/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserForDeveloperRequest calls the generic CreateUserForDeveloper builder with application/json body
func NewCreateUserForDeveloperRequest(server string, body CreateUserForDeveloperJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserForDeveloperRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserForDeveloperRequestWithBody generates requests for CreateUserForDeveloper with any type of body
func NewCreateUserForDeveloperRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssignRoleToUserRequest calls the generic AssignRoleToUser builder with application/json body
func NewAssignRoleToUserRequest(server string, body AssignRoleToUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssignRoleToUserRequestWithBody(server, "application/json", bodyReader)
}

// NewAssignRoleToUserRequestWithBody generates requests for AssignRoleToUser with any type of body
func NewAssignRoleToUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/assignrole")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConfirmUserRequest calls the generic ConfirmUser builder with application/json body
func NewConfirmUserRequest(server string, body ConfirmUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfirmUserRequestWithBody(server, "application/json", bodyReader)
}

// NewConfirmUserRequestWithBody generates requests for ConfirmUser with any type of body
func NewConfirmUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/confirm")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLoginUserRequest calls the generic LoginUser builder with application/json body
func NewLoginUserRequest(server string, body LoginUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginUserRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginUserRequestWithBody generates requests for LoginUser with any type of body
func NewLoginUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOktaAuthorizeHandlerRequest generates requests for OktaAuthorizeHandler
func NewOktaAuthorizeHandlerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/okta/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOktaSAMLAuthorizeHandlerRequest generates requests for OktaSAMLAuthorizeHandler
func NewOktaSAMLAuthorizeHandlerRequest(server string, connectionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/okta/connection/%s/saml/acs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOktaLoginHandlerRequest generates requests for OktaLoginHandler
func NewOktaLoginHandlerRequest(server string, connectionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/okta/login/connection/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOktaSAMLLoginHandlerRequest generates requests for OktaSAMLLoginHandler
func NewOktaSAMLLoginHandlerRequest(server string, connectionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/okta/saml/login/connection/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetUserPasswordRequest calls the generic SetUserPassword builder with application/json body
func NewSetUserPasswordRequest(server string, body SetUserPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetUserPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewSetUserPasswordRequestWithBody generates requests for SetUserPassword with any type of body
func NewSetUserPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/setpassword")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserWithoutDeveloperRequest generates requests for GetUserWithoutDeveloper
func NewGetUserWithoutDeveloperRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, userId string, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServicePublicKeysRequest generates requests for GetServicePublicKeys
func NewGetServicePublicKeysRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/.well-known/jwks.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetClientKeyList request
	GetClientKeyListWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetClientKeyListResponse, error)

	// CreateClientKey request with any body
	CreateClientKeyWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientKeyResponse, error)

	CreateClientKeyWithResponse(ctx context.Context, accountId string, body CreateClientKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientKeyResponse, error)

	// DeleteClientKey request
	DeleteClientKeyWithResponse(ctx context.Context, accountId string, clientId string, reqEditors ...RequestEditorFn) (*DeleteClientKeyResponse, error)

	// GetClientKey request
	GetClientKeyWithResponse(ctx context.Context, accountId string, clientId string, reqEditors ...RequestEditorFn) (*GetClientKeyResponse, error)

	// CreateOKTAConnection request with any body
	CreateOKTAConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOKTAConnectionResponse, error)

	CreateOKTAConnectionWithResponse(ctx context.Context, body CreateOKTAConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOKTAConnectionResponse, error)

	// GetOKTAConnection request
	GetOKTAConnectionWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*GetOKTAConnectionResponse, error)

	// CreateSAMLConnection request with any body
	CreateSAMLConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSAMLConnectionResponse, error)

	CreateSAMLConnectionWithResponse(ctx context.Context, body CreateSAMLConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSAMLConnectionResponse, error)

	// UpdateSAMLConnection request with any body
	UpdateSAMLConnectionWithBodyWithResponse(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSAMLConnectionResponse, error)

	UpdateSAMLConnectionWithResponse(ctx context.Context, connectionId string, body UpdateSAMLConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSAMLConnectionResponse, error)

	// CreateSAMLConnectionMapping request with any body
	CreateSAMLConnectionMappingWithBodyWithResponse(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSAMLConnectionMappingResponse, error)

	CreateSAMLConnectionMappingWithResponse(ctx context.Context, connectionId string, body CreateSAMLConnectionMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSAMLConnectionMappingResponse, error)

	// CreateDeveloper request with any body
	CreateDeveloperWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeveloperResponse, error)

	CreateDeveloperWithResponse(ctx context.Context, serviceId string, body CreateDeveloperJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeveloperResponse, error)

	// GetDeveloperByServiceAndEmail request
	GetDeveloperByServiceAndEmailWithResponse(ctx context.Context, serviceId string, userId string, reqEditors ...RequestEditorFn) (*GetDeveloperByServiceAndEmailResponse, error)

	// GetDeveloper request
	GetDeveloperWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetDeveloperResponse, error)

	// GetHealthz request
	GetHealthzWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthzResponse, error)

	// GetOAuthToken request with any body
	GetOAuthTokenWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error)

	GetOAuthTokenWithResponse(ctx context.Context, accountId string, body GetOAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error)

	// GetOwnAccountInfo request
	GetOwnAccountInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOwnAccountInfoResponse, error)

	// GetAccountInfo request
	GetAccountInfoWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetAccountInfoResponse, error)

	// GetOIDCConnectionsForAccount request
	GetOIDCConnectionsForAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetOIDCConnectionsForAccountResponse, error)

	// GetSAMLConnectionsForAccount request
	GetSAMLConnectionsForAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetSAMLConnectionsForAccountResponse, error)

	// GetRolesForAccount request
	GetRolesForAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetRolesForAccountResponse, error)

	// GetRole request
	GetRoleWithResponse(ctx context.Context, accountId string, roleId string, reqEditors ...RequestEditorFn) (*GetRoleResponse, error)

	// GetUsersForAccount request
	GetUsersForAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetUsersForAccountResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, accountId string, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// CreateRole request with any body
	CreateRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error)

	CreateRoleWithResponse(ctx context.Context, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error)

	// AssumeRole request
	AssumeRoleWithResponse(ctx context.Context, accountId string, roleId string, reqEditors ...RequestEditorFn) (*AssumeRoleResponse, error)

	// CreateService request with any body
	CreateServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error)

	CreateServiceWithResponse(ctx context.Context, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error)

	// GetDefaultService request
	GetDefaultServiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultServiceResponse, error)

	// AddSpecForService request with any body
	AddSpecForServiceWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddSpecForServiceResponse, error)

	// GetService request
	GetServiceWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServiceResponse, error)

	// CreateTags request with any body
	CreateTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error)

	CreateTagsWithResponse(ctx context.Context, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error)

	// GetTagsForResource request
	GetTagsForResourceWithResponse(ctx context.Context, serviceId string, accountId string, name string, resourceId string, reqEditors ...RequestEditorFn) (*GetTagsForResourceResponse, error)

	// CreateUserForDeveloper request with any body
	CreateUserForDeveloperWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserForDeveloperResponse, error)

	CreateUserForDeveloperWithResponse(ctx context.Context, body CreateUserForDeveloperJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserForDeveloperResponse, error)

	// AssignRoleToUser request with any body
	AssignRoleToUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignRoleToUserResponse, error)

	AssignRoleToUserWithResponse(ctx context.Context, body AssignRoleToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignRoleToUserResponse, error)

	// ConfirmUser request with any body
	ConfirmUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmUserResponse, error)

	ConfirmUserWithResponse(ctx context.Context, body ConfirmUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmUserResponse, error)

	// LoginUser request with any body
	LoginUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginUserResponse, error)

	LoginUserWithResponse(ctx context.Context, body LoginUserJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginUserResponse, error)

	// OktaAuthorizeHandler request
	OktaAuthorizeHandlerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OktaAuthorizeHandlerResponse, error)

	// OktaSAMLAuthorizeHandler request
	OktaSAMLAuthorizeHandlerWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*OktaSAMLAuthorizeHandlerResponse, error)

	// OktaLoginHandler request
	OktaLoginHandlerWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*OktaLoginHandlerResponse, error)

	// OktaSAMLLoginHandler request
	OktaSAMLLoginHandlerWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*OktaSAMLLoginHandlerResponse, error)

	// SetUserPassword request with any body
	SetUserPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetUserPasswordResponse, error)

	SetUserPasswordWithResponse(ctx context.Context, body SetUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*SetUserPasswordResponse, error)

	// GetUserWithoutDeveloper request
	GetUserWithoutDeveloperWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserWithoutDeveloperResponse, error)

	// UpdateUser request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// GetServicePublicKeys request
	GetServicePublicKeysWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServicePublicKeysResponse, error)
}

type GetClientKeyListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClientKeyObject
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetClientKeyListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientKeyListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClientKeyResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateClientKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClientKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteClientKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClientKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClientKeyObject
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetClientKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOKTAConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OktaObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateOKTAConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOKTAConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOKTAConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OktaObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetOKTAConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOKTAConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSAMLConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SAMLObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateSAMLConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSAMLConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSAMLConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SAMLObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateSAMLConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSAMLConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSAMLConnectionMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SAMLObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateSAMLConnectionMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSAMLConnectionMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDeveloperResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Developer
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateDeveloperResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDeveloperResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeveloperByServiceAndEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Developer
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetDeveloperByServiceAndEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeveloperByServiceAndEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeveloperResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Developer
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetDeveloperResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeveloperResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHealthzResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetHealthzResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHealthzResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOAuthTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthTokenResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetOAuthTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOAuthTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOwnAccountInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Organization
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetOwnAccountInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOwnAccountInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Organization
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAccountInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOIDCConnectionsForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OktaObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetOIDCConnectionsForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOIDCConnectionsForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSAMLConnectionsForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SAMLObj
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSAMLConnectionsForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSAMLConnectionsForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRolesForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Role
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRolesForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRolesForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Role
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]User
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUsersForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Role
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssumeRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AssumeRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssumeRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Service
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Service
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetDefaultServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddSpecForServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Service
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AddSpecForServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddSpecForServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Service
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tags
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsForResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string][]string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetTagsForResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsForResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserForDeveloperResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserForDeveloperResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserForDeveloperResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignRoleToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AssignRoleToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignRoleToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserConfirmation
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ConfirmUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LoginUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OktaAuthorizeHandlerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r OktaAuthorizeHandlerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OktaAuthorizeHandlerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OktaSAMLAuthorizeHandlerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r OktaSAMLAuthorizeHandlerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OktaSAMLAuthorizeHandlerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OktaLoginHandlerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r OktaLoginHandlerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OktaLoginHandlerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OktaSAMLLoginHandlerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r OktaSAMLLoginHandlerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OktaSAMLLoginHandlerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetUserPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetUserPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetUserPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserWithoutDeveloperResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUserWithoutDeveloperResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserWithoutDeveloperResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicePublicKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Keys *[]OIDCPublicKey `json:"keys,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GetServicePublicKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicePublicKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetClientKeyListWithResponse request returning *GetClientKeyListResponse
func (c *ClientWithResponses) GetClientKeyListWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetClientKeyListResponse, error) {
	rsp, err := c.GetClientKeyList(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientKeyListResponse(rsp)
}

// CreateClientKeyWithBodyWithResponse request with arbitrary body returning *CreateClientKeyResponse
func (c *ClientWithResponses) CreateClientKeyWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientKeyResponse, error) {
	rsp, err := c.CreateClientKeyWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateClientKeyWithResponse(ctx context.Context, accountId string, body CreateClientKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientKeyResponse, error) {
	rsp, err := c.CreateClientKey(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientKeyResponse(rsp)
}

// DeleteClientKeyWithResponse request returning *DeleteClientKeyResponse
func (c *ClientWithResponses) DeleteClientKeyWithResponse(ctx context.Context, accountId string, clientId string, reqEditors ...RequestEditorFn) (*DeleteClientKeyResponse, error) {
	rsp, err := c.DeleteClientKey(ctx, accountId, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClientKeyResponse(rsp)
}

// GetClientKeyWithResponse request returning *GetClientKeyResponse
func (c *ClientWithResponses) GetClientKeyWithResponse(ctx context.Context, accountId string, clientId string, reqEditors ...RequestEditorFn) (*GetClientKeyResponse, error) {
	rsp, err := c.GetClientKey(ctx, accountId, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientKeyResponse(rsp)
}

// CreateOKTAConnectionWithBodyWithResponse request with arbitrary body returning *CreateOKTAConnectionResponse
func (c *ClientWithResponses) CreateOKTAConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOKTAConnectionResponse, error) {
	rsp, err := c.CreateOKTAConnectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOKTAConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateOKTAConnectionWithResponse(ctx context.Context, body CreateOKTAConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOKTAConnectionResponse, error) {
	rsp, err := c.CreateOKTAConnection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOKTAConnectionResponse(rsp)
}

// GetOKTAConnectionWithResponse request returning *GetOKTAConnectionResponse
func (c *ClientWithResponses) GetOKTAConnectionWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*GetOKTAConnectionResponse, error) {
	rsp, err := c.GetOKTAConnection(ctx, connectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOKTAConnectionResponse(rsp)
}

// CreateSAMLConnectionWithBodyWithResponse request with arbitrary body returning *CreateSAMLConnectionResponse
func (c *ClientWithResponses) CreateSAMLConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSAMLConnectionResponse, error) {
	rsp, err := c.CreateSAMLConnectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSAMLConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateSAMLConnectionWithResponse(ctx context.Context, body CreateSAMLConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSAMLConnectionResponse, error) {
	rsp, err := c.CreateSAMLConnection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSAMLConnectionResponse(rsp)
}

// UpdateSAMLConnectionWithBodyWithResponse request with arbitrary body returning *UpdateSAMLConnectionResponse
func (c *ClientWithResponses) UpdateSAMLConnectionWithBodyWithResponse(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSAMLConnectionResponse, error) {
	rsp, err := c.UpdateSAMLConnectionWithBody(ctx, connectionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSAMLConnectionResponse(rsp)
}

func (c *ClientWithResponses) UpdateSAMLConnectionWithResponse(ctx context.Context, connectionId string, body UpdateSAMLConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSAMLConnectionResponse, error) {
	rsp, err := c.UpdateSAMLConnection(ctx, connectionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSAMLConnectionResponse(rsp)
}

// CreateSAMLConnectionMappingWithBodyWithResponse request with arbitrary body returning *CreateSAMLConnectionMappingResponse
func (c *ClientWithResponses) CreateSAMLConnectionMappingWithBodyWithResponse(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSAMLConnectionMappingResponse, error) {
	rsp, err := c.CreateSAMLConnectionMappingWithBody(ctx, connectionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSAMLConnectionMappingResponse(rsp)
}

func (c *ClientWithResponses) CreateSAMLConnectionMappingWithResponse(ctx context.Context, connectionId string, body CreateSAMLConnectionMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSAMLConnectionMappingResponse, error) {
	rsp, err := c.CreateSAMLConnectionMapping(ctx, connectionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSAMLConnectionMappingResponse(rsp)
}

// CreateDeveloperWithBodyWithResponse request with arbitrary body returning *CreateDeveloperResponse
func (c *ClientWithResponses) CreateDeveloperWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeveloperResponse, error) {
	rsp, err := c.CreateDeveloperWithBody(ctx, serviceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeveloperResponse(rsp)
}

func (c *ClientWithResponses) CreateDeveloperWithResponse(ctx context.Context, serviceId string, body CreateDeveloperJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeveloperResponse, error) {
	rsp, err := c.CreateDeveloper(ctx, serviceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeveloperResponse(rsp)
}

// GetDeveloperByServiceAndEmailWithResponse request returning *GetDeveloperByServiceAndEmailResponse
func (c *ClientWithResponses) GetDeveloperByServiceAndEmailWithResponse(ctx context.Context, serviceId string, userId string, reqEditors ...RequestEditorFn) (*GetDeveloperByServiceAndEmailResponse, error) {
	rsp, err := c.GetDeveloperByServiceAndEmail(ctx, serviceId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeveloperByServiceAndEmailResponse(rsp)
}

// GetDeveloperWithResponse request returning *GetDeveloperResponse
func (c *ClientWithResponses) GetDeveloperWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetDeveloperResponse, error) {
	rsp, err := c.GetDeveloper(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeveloperResponse(rsp)
}

// GetHealthzWithResponse request returning *GetHealthzResponse
func (c *ClientWithResponses) GetHealthzWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthzResponse, error) {
	rsp, err := c.GetHealthz(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHealthzResponse(rsp)
}

// GetOAuthTokenWithBodyWithResponse request with arbitrary body returning *GetOAuthTokenResponse
func (c *ClientWithResponses) GetOAuthTokenWithBodyWithResponse(ctx context.Context, accountId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error) {
	rsp, err := c.GetOAuthTokenWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthTokenResponse(rsp)
}

func (c *ClientWithResponses) GetOAuthTokenWithResponse(ctx context.Context, accountId string, body GetOAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error) {
	rsp, err := c.GetOAuthToken(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthTokenResponse(rsp)
}

// GetOwnAccountInfoWithResponse request returning *GetOwnAccountInfoResponse
func (c *ClientWithResponses) GetOwnAccountInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOwnAccountInfoResponse, error) {
	rsp, err := c.GetOwnAccountInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOwnAccountInfoResponse(rsp)
}

// GetAccountInfoWithResponse request returning *GetAccountInfoResponse
func (c *ClientWithResponses) GetAccountInfoWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetAccountInfoResponse, error) {
	rsp, err := c.GetAccountInfo(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountInfoResponse(rsp)
}

// GetOIDCConnectionsForAccountWithResponse request returning *GetOIDCConnectionsForAccountResponse
func (c *ClientWithResponses) GetOIDCConnectionsForAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetOIDCConnectionsForAccountResponse, error) {
	rsp, err := c.GetOIDCConnectionsForAccount(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOIDCConnectionsForAccountResponse(rsp)
}

// GetSAMLConnectionsForAccountWithResponse request returning *GetSAMLConnectionsForAccountResponse
func (c *ClientWithResponses) GetSAMLConnectionsForAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetSAMLConnectionsForAccountResponse, error) {
	rsp, err := c.GetSAMLConnectionsForAccount(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSAMLConnectionsForAccountResponse(rsp)
}

// GetRolesForAccountWithResponse request returning *GetRolesForAccountResponse
func (c *ClientWithResponses) GetRolesForAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetRolesForAccountResponse, error) {
	rsp, err := c.GetRolesForAccount(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolesForAccountResponse(rsp)
}

// GetRoleWithResponse request returning *GetRoleResponse
func (c *ClientWithResponses) GetRoleWithResponse(ctx context.Context, accountId string, roleId string, reqEditors ...RequestEditorFn) (*GetRoleResponse, error) {
	rsp, err := c.GetRole(ctx, accountId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleResponse(rsp)
}

// GetUsersForAccountWithResponse request returning *GetUsersForAccountResponse
func (c *ClientWithResponses) GetUsersForAccountWithResponse(ctx context.Context, accountId string, reqEditors ...RequestEditorFn) (*GetUsersForAccountResponse, error) {
	rsp, err := c.GetUsersForAccount(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersForAccountResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, accountId string, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, accountId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// CreateRoleWithBodyWithResponse request with arbitrary body returning *CreateRoleResponse
func (c *ClientWithResponses) CreateRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error) {
	rsp, err := c.CreateRoleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleResponse(rsp)
}

func (c *ClientWithResponses) CreateRoleWithResponse(ctx context.Context, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error) {
	rsp, err := c.CreateRole(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleResponse(rsp)
}

// AssumeRoleWithResponse request returning *AssumeRoleResponse
func (c *ClientWithResponses) AssumeRoleWithResponse(ctx context.Context, accountId string, roleId string, reqEditors ...RequestEditorFn) (*AssumeRoleResponse, error) {
	rsp, err := c.AssumeRole(ctx, accountId, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssumeRoleResponse(rsp)
}

// CreateServiceWithBodyWithResponse request with arbitrary body returning *CreateServiceResponse
func (c *ClientWithResponses) CreateServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error) {
	rsp, err := c.CreateServiceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceWithResponse(ctx context.Context, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error) {
	rsp, err := c.CreateService(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceResponse(rsp)
}

// GetDefaultServiceWithResponse request returning *GetDefaultServiceResponse
func (c *ClientWithResponses) GetDefaultServiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultServiceResponse, error) {
	rsp, err := c.GetDefaultService(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultServiceResponse(rsp)
}

// AddSpecForServiceWithBodyWithResponse request with arbitrary body returning *AddSpecForServiceResponse
func (c *ClientWithResponses) AddSpecForServiceWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddSpecForServiceResponse, error) {
	rsp, err := c.AddSpecForServiceWithBody(ctx, serviceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddSpecForServiceResponse(rsp)
}

// GetServiceWithResponse request returning *GetServiceResponse
func (c *ClientWithResponses) GetServiceWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServiceResponse, error) {
	rsp, err := c.GetService(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceResponse(rsp)
}

// CreateTagsWithBodyWithResponse request with arbitrary body returning *CreateTagsResponse
func (c *ClientWithResponses) CreateTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error) {
	rsp, err := c.CreateTagsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagsResponse(rsp)
}

func (c *ClientWithResponses) CreateTagsWithResponse(ctx context.Context, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error) {
	rsp, err := c.CreateTags(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagsResponse(rsp)
}

// GetTagsForResourceWithResponse request returning *GetTagsForResourceResponse
func (c *ClientWithResponses) GetTagsForResourceWithResponse(ctx context.Context, serviceId string, accountId string, name string, resourceId string, reqEditors ...RequestEditorFn) (*GetTagsForResourceResponse, error) {
	rsp, err := c.GetTagsForResource(ctx, serviceId, accountId, name, resourceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsForResourceResponse(rsp)
}

// CreateUserForDeveloperWithBodyWithResponse request with arbitrary body returning *CreateUserForDeveloperResponse
func (c *ClientWithResponses) CreateUserForDeveloperWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserForDeveloperResponse, error) {
	rsp, err := c.CreateUserForDeveloperWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserForDeveloperResponse(rsp)
}

func (c *ClientWithResponses) CreateUserForDeveloperWithResponse(ctx context.Context, body CreateUserForDeveloperJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserForDeveloperResponse, error) {
	rsp, err := c.CreateUserForDeveloper(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserForDeveloperResponse(rsp)
}

// AssignRoleToUserWithBodyWithResponse request with arbitrary body returning *AssignRoleToUserResponse
func (c *ClientWithResponses) AssignRoleToUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignRoleToUserResponse, error) {
	rsp, err := c.AssignRoleToUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignRoleToUserResponse(rsp)
}

func (c *ClientWithResponses) AssignRoleToUserWithResponse(ctx context.Context, body AssignRoleToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignRoleToUserResponse, error) {
	rsp, err := c.AssignRoleToUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignRoleToUserResponse(rsp)
}

// ConfirmUserWithBodyWithResponse request with arbitrary body returning *ConfirmUserResponse
func (c *ClientWithResponses) ConfirmUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmUserResponse, error) {
	rsp, err := c.ConfirmUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmUserResponse(rsp)
}

func (c *ClientWithResponses) ConfirmUserWithResponse(ctx context.Context, body ConfirmUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmUserResponse, error) {
	rsp, err := c.ConfirmUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmUserResponse(rsp)
}

// LoginUserWithBodyWithResponse request with arbitrary body returning *LoginUserResponse
func (c *ClientWithResponses) LoginUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginUserResponse, error) {
	rsp, err := c.LoginUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginUserResponse(rsp)
}

func (c *ClientWithResponses) LoginUserWithResponse(ctx context.Context, body LoginUserJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginUserResponse, error) {
	rsp, err := c.LoginUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginUserResponse(rsp)
}

// OktaAuthorizeHandlerWithResponse request returning *OktaAuthorizeHandlerResponse
func (c *ClientWithResponses) OktaAuthorizeHandlerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OktaAuthorizeHandlerResponse, error) {
	rsp, err := c.OktaAuthorizeHandler(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOktaAuthorizeHandlerResponse(rsp)
}

// OktaSAMLAuthorizeHandlerWithResponse request returning *OktaSAMLAuthorizeHandlerResponse
func (c *ClientWithResponses) OktaSAMLAuthorizeHandlerWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*OktaSAMLAuthorizeHandlerResponse, error) {
	rsp, err := c.OktaSAMLAuthorizeHandler(ctx, connectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOktaSAMLAuthorizeHandlerResponse(rsp)
}

// OktaLoginHandlerWithResponse request returning *OktaLoginHandlerResponse
func (c *ClientWithResponses) OktaLoginHandlerWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*OktaLoginHandlerResponse, error) {
	rsp, err := c.OktaLoginHandler(ctx, connectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOktaLoginHandlerResponse(rsp)
}

// OktaSAMLLoginHandlerWithResponse request returning *OktaSAMLLoginHandlerResponse
func (c *ClientWithResponses) OktaSAMLLoginHandlerWithResponse(ctx context.Context, connectionId string, reqEditors ...RequestEditorFn) (*OktaSAMLLoginHandlerResponse, error) {
	rsp, err := c.OktaSAMLLoginHandler(ctx, connectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOktaSAMLLoginHandlerResponse(rsp)
}

// SetUserPasswordWithBodyWithResponse request with arbitrary body returning *SetUserPasswordResponse
func (c *ClientWithResponses) SetUserPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetUserPasswordResponse, error) {
	rsp, err := c.SetUserPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetUserPasswordResponse(rsp)
}

func (c *ClientWithResponses) SetUserPasswordWithResponse(ctx context.Context, body SetUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*SetUserPasswordResponse, error) {
	rsp, err := c.SetUserPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetUserPasswordResponse(rsp)
}

// GetUserWithoutDeveloperWithResponse request returning *GetUserWithoutDeveloperResponse
func (c *ClientWithResponses) GetUserWithoutDeveloperWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserWithoutDeveloperResponse, error) {
	rsp, err := c.GetUserWithoutDeveloper(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserWithoutDeveloperResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// GetServicePublicKeysWithResponse request returning *GetServicePublicKeysResponse
func (c *ClientWithResponses) GetServicePublicKeysWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServicePublicKeysResponse, error) {
	rsp, err := c.GetServicePublicKeys(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicePublicKeysResponse(rsp)
}

// ParseGetClientKeyListResponse parses an HTTP response from a GetClientKeyListWithResponse call
func ParseGetClientKeyListResponse(rsp *http.Response) (*GetClientKeyListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientKeyListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClientKeyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateClientKeyResponse parses an HTTP response from a CreateClientKeyWithResponse call
func ParseCreateClientKeyResponse(rsp *http.Response) (*CreateClientKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClientKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteClientKeyResponse parses an HTTP response from a DeleteClientKeyWithResponse call
func ParseDeleteClientKeyResponse(rsp *http.Response) (*DeleteClientKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClientKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClientKeyResponse parses an HTTP response from a GetClientKeyWithResponse call
func ParseGetClientKeyResponse(rsp *http.Response) (*GetClientKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClientKeyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateOKTAConnectionResponse parses an HTTP response from a CreateOKTAConnectionWithResponse call
func ParseCreateOKTAConnectionResponse(rsp *http.Response) (*CreateOKTAConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOKTAConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OktaObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOKTAConnectionResponse parses an HTTP response from a GetOKTAConnectionWithResponse call
func ParseGetOKTAConnectionResponse(rsp *http.Response) (*GetOKTAConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOKTAConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OktaObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSAMLConnectionResponse parses an HTTP response from a CreateSAMLConnectionWithResponse call
func ParseCreateSAMLConnectionResponse(rsp *http.Response) (*CreateSAMLConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSAMLConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SAMLObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateSAMLConnectionResponse parses an HTTP response from a UpdateSAMLConnectionWithResponse call
func ParseUpdateSAMLConnectionResponse(rsp *http.Response) (*UpdateSAMLConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSAMLConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SAMLObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSAMLConnectionMappingResponse parses an HTTP response from a CreateSAMLConnectionMappingWithResponse call
func ParseCreateSAMLConnectionMappingResponse(rsp *http.Response) (*CreateSAMLConnectionMappingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSAMLConnectionMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SAMLObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDeveloperResponse parses an HTTP response from a CreateDeveloperWithResponse call
func ParseCreateDeveloperResponse(rsp *http.Response) (*CreateDeveloperResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDeveloperResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Developer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDeveloperByServiceAndEmailResponse parses an HTTP response from a GetDeveloperByServiceAndEmailWithResponse call
func ParseGetDeveloperByServiceAndEmailResponse(rsp *http.Response) (*GetDeveloperByServiceAndEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeveloperByServiceAndEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Developer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDeveloperResponse parses an HTTP response from a GetDeveloperWithResponse call
func ParseGetDeveloperResponse(rsp *http.Response) (*GetDeveloperResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeveloperResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Developer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHealthzResponse parses an HTTP response from a GetHealthzWithResponse call
func ParseGetHealthzResponse(rsp *http.Response) (*GetHealthzResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHealthzResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOAuthTokenResponse parses an HTTP response from a GetOAuthTokenWithResponse call
func ParseGetOAuthTokenResponse(rsp *http.Response) (*GetOAuthTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOAuthTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOwnAccountInfoResponse parses an HTTP response from a GetOwnAccountInfoWithResponse call
func ParseGetOwnAccountInfoResponse(rsp *http.Response) (*GetOwnAccountInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOwnAccountInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAccountInfoResponse parses an HTTP response from a GetAccountInfoWithResponse call
func ParseGetAccountInfoResponse(rsp *http.Response) (*GetAccountInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOIDCConnectionsForAccountResponse parses an HTTP response from a GetOIDCConnectionsForAccountWithResponse call
func ParseGetOIDCConnectionsForAccountResponse(rsp *http.Response) (*GetOIDCConnectionsForAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOIDCConnectionsForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OktaObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSAMLConnectionsForAccountResponse parses an HTTP response from a GetSAMLConnectionsForAccountWithResponse call
func ParseGetSAMLConnectionsForAccountResponse(rsp *http.Response) (*GetSAMLConnectionsForAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSAMLConnectionsForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SAMLObj
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRolesForAccountResponse parses an HTTP response from a GetRolesForAccountWithResponse call
func ParseGetRolesForAccountResponse(rsp *http.Response) (*GetRolesForAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRolesForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRoleResponse parses an HTTP response from a GetRoleWithResponse call
func ParseGetRoleResponse(rsp *http.Response) (*GetRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUsersForAccountResponse parses an HTTP response from a GetUsersForAccountWithResponse call
func ParseGetUsersForAccountResponse(rsp *http.Response) (*GetUsersForAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateRoleResponse parses an HTTP response from a CreateRoleWithResponse call
func ParseCreateRoleResponse(rsp *http.Response) (*CreateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAssumeRoleResponse parses an HTTP response from a AssumeRoleWithResponse call
func ParseAssumeRoleResponse(rsp *http.Response) (*AssumeRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssumeRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServiceResponse parses an HTTP response from a CreateServiceWithResponse call
func ParseCreateServiceResponse(rsp *http.Response) (*CreateServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDefaultServiceResponse parses an HTTP response from a GetDefaultServiceWithResponse call
func ParseGetDefaultServiceResponse(rsp *http.Response) (*GetDefaultServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddSpecForServiceResponse parses an HTTP response from a AddSpecForServiceWithResponse call
func ParseAddSpecForServiceResponse(rsp *http.Response) (*AddSpecForServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddSpecForServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServiceResponse parses an HTTP response from a GetServiceWithResponse call
func ParseGetServiceResponse(rsp *http.Response) (*GetServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTagsResponse parses an HTTP response from a CreateTagsWithResponse call
func ParseCreateTagsResponse(rsp *http.Response) (*CreateTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tags
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTagsForResourceResponse parses an HTTP response from a GetTagsForResourceWithResponse call
func ParseGetTagsForResourceResponse(rsp *http.Response) (*GetTagsForResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsForResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string][]string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserForDeveloperResponse parses an HTTP response from a CreateUserForDeveloperWithResponse call
func ParseCreateUserForDeveloperResponse(rsp *http.Response) (*CreateUserForDeveloperResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserForDeveloperResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAssignRoleToUserResponse parses an HTTP response from a AssignRoleToUserWithResponse call
func ParseAssignRoleToUserResponse(rsp *http.Response) (*AssignRoleToUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignRoleToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseConfirmUserResponse parses an HTTP response from a ConfirmUserWithResponse call
func ParseConfirmUserResponse(rsp *http.Response) (*ConfirmUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserConfirmation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLoginUserResponse parses an HTTP response from a LoginUserWithResponse call
func ParseLoginUserResponse(rsp *http.Response) (*LoginUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOktaAuthorizeHandlerResponse parses an HTTP response from a OktaAuthorizeHandlerWithResponse call
func ParseOktaAuthorizeHandlerResponse(rsp *http.Response) (*OktaAuthorizeHandlerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OktaAuthorizeHandlerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOktaSAMLAuthorizeHandlerResponse parses an HTTP response from a OktaSAMLAuthorizeHandlerWithResponse call
func ParseOktaSAMLAuthorizeHandlerResponse(rsp *http.Response) (*OktaSAMLAuthorizeHandlerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OktaSAMLAuthorizeHandlerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOktaLoginHandlerResponse parses an HTTP response from a OktaLoginHandlerWithResponse call
func ParseOktaLoginHandlerResponse(rsp *http.Response) (*OktaLoginHandlerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OktaLoginHandlerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOktaSAMLLoginHandlerResponse parses an HTTP response from a OktaSAMLLoginHandlerWithResponse call
func ParseOktaSAMLLoginHandlerResponse(rsp *http.Response) (*OktaSAMLLoginHandlerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OktaSAMLLoginHandlerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetUserPasswordResponse parses an HTTP response from a SetUserPasswordWithResponse call
func ParseSetUserPasswordResponse(rsp *http.Response) (*SetUserPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetUserPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserWithoutDeveloperResponse parses an HTTP response from a GetUserWithoutDeveloperWithResponse call
func ParseGetUserWithoutDeveloperResponse(rsp *http.Response) (*GetUserWithoutDeveloperResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserWithoutDeveloperResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServicePublicKeysResponse parses an HTTP response from a GetServicePublicKeysWithResponse call
func ParseGetServicePublicKeysResponse(rsp *http.Response) (*GetServicePublicKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicePublicKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Keys *[]OIDCPublicKey `json:"keys,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get list of all client keys
	// (GET /clientkey/{accountId})
	GetClientKeyList(ctx echo.Context, accountId string) error
	// Creates a new client key
	// (POST /clientkey/{accountId})
	CreateClientKey(ctx echo.Context, accountId string) error
	// delete a client key
	// (DELETE /clientkey/{accountId}/{clientId})
	DeleteClientKey(ctx echo.Context, accountId string, clientId string) error
	// Get details of client key
	// (GET /clientkey/{accountId}/{clientId})
	GetClientKey(ctx echo.Context, accountId string, clientId string) error
	// Creates a new OKTA connection
	// (POST /connections/okta)
	CreateOKTAConnection(ctx echo.Context) error
	// Return existing connection
	// (GET /connections/okta/connection/{connectionId})
	GetOKTAConnection(ctx echo.Context, connectionId string) error
	// Creates a new SAML connection
	// (POST /connections/saml)
	CreateSAMLConnection(ctx echo.Context) error
	// Updates a SAML connection
	// (PUT /connections/saml/connection/{connectionId})
	UpdateSAMLConnection(ctx echo.Context, connectionId string) error
	// Creates a new attribute mapping for a SAML connection
	// (POST /connections/saml/mapping/connection/{connectionId})
	CreateSAMLConnectionMapping(ctx echo.Context, connectionId string) error
	// Creates a new Developer account against the requested service
	// (POST /developer/service/{serviceId})
	CreateDeveloper(ctx echo.Context, serviceId string) error
	// Gets a developer corresponding to a service and user (email).
	// (GET /developer/service/{serviceId}/user/{userId})
	GetDeveloperByServiceAndEmail(ctx echo.Context, serviceId string, userId string) error
	// Gets a developer object
	// (GET /developer/{accountId})
	GetDeveloper(ctx echo.Context, accountId string) error
	// Returns service health
	// (GET /healthz)
	GetHealthz(ctx echo.Context) error
	// get token for client id / secret
	// (POST /oauth/{accountId}/token)
	GetOAuthToken(ctx echo.Context, accountId string) error
	// Returns an object with information regarding an account which is present in the token
	// (GET /org)
	GetOwnAccountInfo(ctx echo.Context) error
	// Returns an object with information regarding an account
	// (GET /org/{accountId})
	GetAccountInfo(ctx echo.Context, accountId string) error
	// Returns a list of all OIDC connections belonging to provided account ID
	// (GET /org/{accountId}/connections/oidc)
	GetOIDCConnectionsForAccount(ctx echo.Context, accountId string) error
	// Returns a list of all SAML connections belonging to provided account ID
	// (GET /org/{accountId}/connections/saml)
	GetSAMLConnectionsForAccount(ctx echo.Context, accountId string) error
	// Returns a list of all roles belonging to provided account ID
	// (GET /org/{accountId}/role)
	GetRolesForAccount(ctx echo.Context, accountId string) error
	// Gets a role
	// (GET /org/{accountId}/role/{roleId})
	GetRole(ctx echo.Context, accountId string, roleId string) error
	// Returns a list of all users belonging to provided account ID
	// (GET /org/{accountId}/user)
	GetUsersForAccount(ctx echo.Context, accountId string) error

	// (GET /org/{accountId}/user/{userId})
	GetUser(ctx echo.Context, accountId string, userId string) error
	// Creates a new Role
	// (POST /role)
	CreateRole(ctx echo.Context) error
	// Creates a token with requested roleId
	// (GET /role/assume/{accountId}/{roleId})
	AssumeRole(ctx echo.Context, accountId string, roleId string) error
	// Creates a new service
	// (POST /service)
	CreateService(ctx echo.Context) error
	// Gets Katanemo service object
	// (GET /service/default)
	GetDefaultService(ctx echo.Context) error
	// Adds an openapi spec to a service
	// (POST /service/openapi/service/{serviceId})
	AddSpecForService(ctx echo.Context, serviceId string) error
	// Gets a service
	// (GET /service/{serviceId})
	GetService(ctx echo.Context, serviceId string) error
	// creates a resource with provided tags
	// (POST /tags)
	CreateTags(ctx echo.Context) error
	// Gets tags for resource
	// (GET /tags/service/{serviceId}/developer/{accountId}/name/{name}/resource/{resourceId})
	GetTagsForResource(ctx echo.Context, serviceId string, accountId string, name string, resourceId string) error
	// Creates a new User account tied to the specified organization
	// (POST /user)
	CreateUserForDeveloper(ctx echo.Context) error
	// Assign role to user
	// (POST /user/assignrole)
	AssignRoleToUser(ctx echo.Context) error
	// Confirms a user account
	// (POST /user/confirm)
	ConfirmUser(ctx echo.Context) error
	// User login
	// (POST /user/login)
	LoginUser(ctx echo.Context) error
	// Receives the callback from Okta
	// (GET /user/okta/callback)
	OktaAuthorizeHandler(ctx echo.Context) error
	// Receives the callback from Okta SAML
	// (POST /user/okta/connection/{connectionId}/saml/acs)
	OktaSAMLAuthorizeHandler(ctx echo.Context, connectionId string) error
	// Triggers okta signin flow
	// (GET /user/okta/login/connection/{connectionId})
	OktaLoginHandler(ctx echo.Context, connectionId string) error
	// Triggers okta signin flow
	// (GET /user/okta/saml/login/connection/{connectionId})
	OktaSAMLLoginHandler(ctx echo.Context, connectionId string) error
	// Set password
	// (POST /user/setpassword)
	SetUserPassword(ctx echo.Context) error
	// Gets a User object
	// (GET /user/{userId})
	GetUserWithoutDeveloper(ctx echo.Context, userId string) error
	// Updates a user
	// (PUT /user/{userId})
	UpdateUser(ctx echo.Context, userId string) error
	// Gets public keys for token verification
	// (GET /{serviceId}/.well-known/jwks.json)
	GetServicePublicKeys(ctx echo.Context, serviceId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetClientKeyList converts echo context to params.
func (w *ServerInterfaceWrapper) GetClientKeyList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetClientKeyList(ctx, accountId)
	return err
}

// CreateClientKey converts echo context to params.
func (w *ServerInterfaceWrapper) CreateClientKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateClientKey(ctx, accountId)
	return err
}

// DeleteClientKey converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteClientKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "clientId" -------------
	var clientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "clientId", runtime.ParamLocationPath, ctx.Param("clientId"), &clientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter clientId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteClientKey(ctx, accountId, clientId)
	return err
}

// GetClientKey converts echo context to params.
func (w *ServerInterfaceWrapper) GetClientKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "clientId" -------------
	var clientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "clientId", runtime.ParamLocationPath, ctx.Param("clientId"), &clientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter clientId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetClientKey(ctx, accountId, clientId)
	return err
}

// CreateOKTAConnection converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOKTAConnection(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateOKTAConnection(ctx)
	return err
}

// GetOKTAConnection converts echo context to params.
func (w *ServerInterfaceWrapper) GetOKTAConnection(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "connectionId" -------------
	var connectionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, ctx.Param("connectionId"), &connectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connectionId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOKTAConnection(ctx, connectionId)
	return err
}

// CreateSAMLConnection converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSAMLConnection(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSAMLConnection(ctx)
	return err
}

// UpdateSAMLConnection converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateSAMLConnection(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "connectionId" -------------
	var connectionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, ctx.Param("connectionId"), &connectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connectionId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateSAMLConnection(ctx, connectionId)
	return err
}

// CreateSAMLConnectionMapping converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSAMLConnectionMapping(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "connectionId" -------------
	var connectionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, ctx.Param("connectionId"), &connectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connectionId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSAMLConnectionMapping(ctx, connectionId)
	return err
}

// CreateDeveloper converts echo context to params.
func (w *ServerInterfaceWrapper) CreateDeveloper(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateDeveloper(ctx, serviceId)
	return err
}

// GetDeveloperByServiceAndEmail converts echo context to params.
func (w *ServerInterfaceWrapper) GetDeveloperByServiceAndEmail(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "userId", runtime.ParamLocationPath, ctx.Param("userId"), &userId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDeveloperByServiceAndEmail(ctx, serviceId, userId)
	return err
}

// GetDeveloper converts echo context to params.
func (w *ServerInterfaceWrapper) GetDeveloper(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDeveloper(ctx, accountId)
	return err
}

// GetHealthz converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealthz(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetHealthz(ctx)
	return err
}

// GetOAuthToken converts echo context to params.
func (w *ServerInterfaceWrapper) GetOAuthToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOAuthToken(ctx, accountId)
	return err
}

// GetOwnAccountInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetOwnAccountInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOwnAccountInfo(ctx)
	return err
}

// GetAccountInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetAccountInfo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAccountInfo(ctx, accountId)
	return err
}

// GetOIDCConnectionsForAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetOIDCConnectionsForAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOIDCConnectionsForAccount(ctx, accountId)
	return err
}

// GetSAMLConnectionsForAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetSAMLConnectionsForAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSAMLConnectionsForAccount(ctx, accountId)
	return err
}

// GetRolesForAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetRolesForAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRolesForAccount(ctx, accountId)
	return err
}

// GetRole converts echo context to params.
func (w *ServerInterfaceWrapper) GetRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "roleId" -------------
	var roleId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "roleId", runtime.ParamLocationPath, ctx.Param("roleId"), &roleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter roleId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRole(ctx, accountId, roleId)
	return err
}

// GetUsersForAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsersForAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUsersForAccount(ctx, accountId)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "userId", runtime.ParamLocationPath, ctx.Param("userId"), &userId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUser(ctx, accountId, userId)
	return err
}

// CreateRole converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRole(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRole(ctx)
	return err
}

// AssumeRole converts echo context to params.
func (w *ServerInterfaceWrapper) AssumeRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "roleId" -------------
	var roleId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "roleId", runtime.ParamLocationPath, ctx.Param("roleId"), &roleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter roleId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AssumeRole(ctx, accountId, roleId)
	return err
}

// CreateService converts echo context to params.
func (w *ServerInterfaceWrapper) CreateService(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateService(ctx)
	return err
}

// GetDefaultService converts echo context to params.
func (w *ServerInterfaceWrapper) GetDefaultService(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDefaultService(ctx)
	return err
}

// AddSpecForService converts echo context to params.
func (w *ServerInterfaceWrapper) AddSpecForService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddSpecForService(ctx, serviceId)
	return err
}

// GetService converts echo context to params.
func (w *ServerInterfaceWrapper) GetService(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetService(ctx, serviceId)
	return err
}

// CreateTags converts echo context to params.
func (w *ServerInterfaceWrapper) CreateTags(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateTags(ctx)
	return err
}

// GetTagsForResource converts echo context to params.
func (w *ServerInterfaceWrapper) GetTagsForResource(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// ------------- Path parameter "accountId" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "accountId", runtime.ParamLocationPath, ctx.Param("accountId"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accountId: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Path parameter "resourceId" -------------
	var resourceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "resourceId", runtime.ParamLocationPath, ctx.Param("resourceId"), &resourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter resourceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTagsForResource(ctx, serviceId, accountId, name, resourceId)
	return err
}

// CreateUserForDeveloper converts echo context to params.
func (w *ServerInterfaceWrapper) CreateUserForDeveloper(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateUserForDeveloper(ctx)
	return err
}

// AssignRoleToUser converts echo context to params.
func (w *ServerInterfaceWrapper) AssignRoleToUser(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AssignRoleToUser(ctx)
	return err
}

// ConfirmUser converts echo context to params.
func (w *ServerInterfaceWrapper) ConfirmUser(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConfirmUser(ctx)
	return err
}

// LoginUser converts echo context to params.
func (w *ServerInterfaceWrapper) LoginUser(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LoginUser(ctx)
	return err
}

// OktaAuthorizeHandler converts echo context to params.
func (w *ServerInterfaceWrapper) OktaAuthorizeHandler(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.OktaAuthorizeHandler(ctx)
	return err
}

// OktaSAMLAuthorizeHandler converts echo context to params.
func (w *ServerInterfaceWrapper) OktaSAMLAuthorizeHandler(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "connectionId" -------------
	var connectionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, ctx.Param("connectionId"), &connectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connectionId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.OktaSAMLAuthorizeHandler(ctx, connectionId)
	return err
}

// OktaLoginHandler converts echo context to params.
func (w *ServerInterfaceWrapper) OktaLoginHandler(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "connectionId" -------------
	var connectionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, ctx.Param("connectionId"), &connectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connectionId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.OktaLoginHandler(ctx, connectionId)
	return err
}

// OktaSAMLLoginHandler converts echo context to params.
func (w *ServerInterfaceWrapper) OktaSAMLLoginHandler(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "connectionId" -------------
	var connectionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, ctx.Param("connectionId"), &connectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter connectionId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.OktaSAMLLoginHandler(ctx, connectionId)
	return err
}

// SetUserPassword converts echo context to params.
func (w *ServerInterfaceWrapper) SetUserPassword(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetUserPassword(ctx)
	return err
}

// GetUserWithoutDeveloper converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserWithoutDeveloper(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "userId", runtime.ParamLocationPath, ctx.Param("userId"), &userId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserWithoutDeveloper(ctx, userId)
	return err
}

// UpdateUser converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "userId", runtime.ParamLocationPath, ctx.Param("userId"), &userId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter userId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateUser(ctx, userId)
	return err
}

// GetServicePublicKeys converts echo context to params.
func (w *ServerInterfaceWrapper) GetServicePublicKeys(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "serviceId" -------------
	var serviceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, ctx.Param("serviceId"), &serviceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serviceId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetServicePublicKeys(ctx, serviceId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/clientkey/:accountId", wrapper.GetClientKeyList)
	router.POST(baseURL+"/clientkey/:accountId", wrapper.CreateClientKey)
	router.DELETE(baseURL+"/clientkey/:accountId/:clientId", wrapper.DeleteClientKey)
	router.GET(baseURL+"/clientkey/:accountId/:clientId", wrapper.GetClientKey)
	router.POST(baseURL+"/connections/okta", wrapper.CreateOKTAConnection)
	router.GET(baseURL+"/connections/okta/connection/:connectionId", wrapper.GetOKTAConnection)
	router.POST(baseURL+"/connections/saml", wrapper.CreateSAMLConnection)
	router.PUT(baseURL+"/connections/saml/connection/:connectionId", wrapper.UpdateSAMLConnection)
	router.POST(baseURL+"/connections/saml/mapping/connection/:connectionId", wrapper.CreateSAMLConnectionMapping)
	router.POST(baseURL+"/developer/service/:serviceId", wrapper.CreateDeveloper)
	router.GET(baseURL+"/developer/service/:serviceId/user/:userId", wrapper.GetDeveloperByServiceAndEmail)
	router.GET(baseURL+"/developer/:accountId", wrapper.GetDeveloper)
	router.GET(baseURL+"/healthz", wrapper.GetHealthz)
	router.POST(baseURL+"/oauth/:accountId/token", wrapper.GetOAuthToken)
	router.GET(baseURL+"/org", wrapper.GetOwnAccountInfo)
	router.GET(baseURL+"/org/:accountId", wrapper.GetAccountInfo)
	router.GET(baseURL+"/org/:accountId/connections/oidc", wrapper.GetOIDCConnectionsForAccount)
	router.GET(baseURL+"/org/:accountId/connections/saml", wrapper.GetSAMLConnectionsForAccount)
	router.GET(baseURL+"/org/:accountId/role", wrapper.GetRolesForAccount)
	router.GET(baseURL+"/org/:accountId/role/:roleId", wrapper.GetRole)
	router.GET(baseURL+"/org/:accountId/user", wrapper.GetUsersForAccount)
	router.GET(baseURL+"/org/:accountId/user/:userId", wrapper.GetUser)
	router.POST(baseURL+"/role", wrapper.CreateRole)
	router.GET(baseURL+"/role/assume/:accountId/:roleId", wrapper.AssumeRole)
	router.POST(baseURL+"/service", wrapper.CreateService)
	router.GET(baseURL+"/service/default", wrapper.GetDefaultService)
	router.POST(baseURL+"/service/openapi/service/:serviceId", wrapper.AddSpecForService)
	router.GET(baseURL+"/service/:serviceId", wrapper.GetService)
	router.POST(baseURL+"/tags", wrapper.CreateTags)
	router.GET(baseURL+"/tags/service/:serviceId/developer/:accountId/name/:name/resource/:resourceId", wrapper.GetTagsForResource)
	router.POST(baseURL+"/user", wrapper.CreateUserForDeveloper)
	router.POST(baseURL+"/user/assignrole", wrapper.AssignRoleToUser)
	router.POST(baseURL+"/user/confirm", wrapper.ConfirmUser)
	router.POST(baseURL+"/user/login", wrapper.LoginUser)
	router.GET(baseURL+"/user/okta/callback", wrapper.OktaAuthorizeHandler)
	router.POST(baseURL+"/user/okta/connection/:connectionId/saml/acs", wrapper.OktaSAMLAuthorizeHandler)
	router.GET(baseURL+"/user/okta/login/connection/:connectionId", wrapper.OktaLoginHandler)
	router.GET(baseURL+"/user/okta/saml/login/connection/:connectionId", wrapper.OktaSAMLLoginHandler)
	router.POST(baseURL+"/user/setpassword", wrapper.SetUserPassword)
	router.GET(baseURL+"/user/:userId", wrapper.GetUserWithoutDeveloper)
	router.PUT(baseURL+"/user/:userId", wrapper.UpdateUser)
	router.GET(baseURL+"/:serviceId/.well-known/jwks.json", wrapper.GetServicePublicKeys)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xdbXPbtpP/Khje/0U7I1t5uLnp+c2daietJ07j8cN15pLcDESuJMQUwAKgHdWj736D",
	"BZ8JSpQoyXTqN20sgLsL7I+Lxe4CfPR8MY8EB66Vd/LoKX8Gc4r/HCnFpvxKhPBp/M38EEkRgdQMsJn6",
	"voi5Pg/MH3oRgXfiKS0Zn3rLgSdFCA1NsQLpbDKPwV8xkxB4J5/Tfl+XA2+ktWTjWIOR5iONItO/LlHa",
	"q0574H0/EjRiR74IYAr8CL5rSY80neKTwYLTuQjG9N47KZBZrhjIJhQTGobcPQ3jjvJZEsvqdOVip1wy",
	"4c0UnoYMuP4Ai0/jb+DrjfS50exlZIyAfsq1K9kioZzwH3QOu6CLdAxZpka+ZvdFomMhQqB8I6oZmRRB",
	"2AW+03kUglGWVczrTEVvsn+99b4OPKZhrpwvT/IDlZIuNsagQnkUyHvmdwZ1TmaJWMwAdgV/xaAcCFul",
	"s+XAC2BC41BfNVmOCt7L3UuI+FoWR0WCK2iSp8FK2cZr8CVolzDLgXcG9xAagmtepgCUL1mkmeD5C0LO",
	"z7zBLt6zAZlRNcPpocGccQdH8zOBOWUhoUEgQSkiJsSXQLWQ5LMETudA9IwpokX6+9dO4iE3+6YachCM",
	"cBYnQs6pNm8I1//x7zkHxjVMQW726maEl4iegjLK48/0RMw4Ow0r51K1FmWW54roGZCcM8WOZAH6v3IB",
	"tjMtNDctIY25P4Pg2r6LVSujtDQmRmn5xv5vX8alJgfamXhspmT89OI5JDECxlGwH2TmhJeJv3MpRFhH",
	"yamYcqYFuVUgienS1ShkrIp8rSVsw9323JUQCV/0ekAqZPrYZVpTKna9eSelcFheQ6c+VuxMsG1QUvXb",
	"N3VVLwfeHJSi00ZCafNgzRqVMEy7m3XpQkwZN1O+hVMdUaUehHQ3rljWt3O6P41iPbsRd8DXrOjbr6BF",
	"Fk2rNPV9UAo7OdnA94hJUOcudBmjYR68wZ/dIpyfnV7G45D5H2Dh4B5O6yD4AAtCw6mQTM/mdRAMPAdw",
	"rq5HBL7bnZbrkTvm8BXuYEFY4OyuF+7u2NPxAHeLNBdBHMYKlOuZWIGbSdyAfjOfd5puCu3t9xc01jMh",
	"2d/UCPeOB5FgXK9A4262IaU9SBPANyebUELSgnPwzaA6S1ygVHAVmVIxyJUzxgX3O+6uLAnDT8hp6viX",
	"4WTwQoScUp5osbuTlvLa02bHuCq0a5DBklimBmqlItAm84lY0alixdMZKMC+Alc08IVZ33Qpwj3FyHZx",
	"dnC5pi1dO4O9pk2iYIF/mkFanVb4Fww/bnhXtCs6D9tRcjuy7QeTPS83fNAovlmwavwn01cyfRUlGY1f",
	"ipD5zlUuFA9P5Z1b5mY4DzOQDhPxp/mZ+CE161EXw2DpW/fxSoSw0b59VJjfnYXHDrM3jozaWQW2/5Iw",
	"8U68fxvmAeBhEv0dJjjpotWMZybA4lRw7dyJ2Gbi23YyDsWYANMzkIRx8k0JToQkCzoPiZ0k8lMoxJ1p",
	"pBFTEfjm97RNTGwow5A5/tnl11h+qVPolMU8MyBwPD0mX9JQ0xdvQL54IgJkS94ev7a/TCWNZuSvkID2",
	"v3id4FGQLJ+3/9nJ7qlMqxzarviFIgTSEeeW9iDzN8zf3OkAILfOa35Gv7boVwIzZxYfQJJOnbiW3YID",
	"xRP2sZm+Hn28OKDX7qsLxu+6krREkKAjP9Te2jmzS51WNKc4dr8SMOA+7GD4RUoH2TKsic9vFkYtksL9",
	"SHApxT0LbPx2e8oFOhggFVPGu092TmaJwSFNA6ppd7olStZMCn17ddE13WiJ7CvZ0+x35t0GtfxMQTPG",
	"FU1c6W1csJ2lTuwrGTFVZ3XBFHoSEdUzhYEbBQEZLypLxz7c4YhdGqaHTZ4Uxl5Pn2R/mRnZxbpZZID8",
	"mYpCunBHCM5sI/oIlcUbrTnlCxIb7TCObddsykkcDQiGWvF/ItaE8oAI9CklhHBPjaMpKQ8Yn5KITh0R",
	"sI1GVBgBjkj48Ry4xs31rXQE/29mQG6vLtBzNWIXn9iljxIIXxkBjFR3aSLeFWYkWhBl5u7bgyYYlXAG",
	"BUMxFa0GVNWR0cPTKyoVH4NSfCyoDBKDWx7NpQStFyTpYng7xtYtTJVzR19fsnvqL1pNbdJ3lzApsLcW",
	"PmASfO2cm6ukEWXCTTXJYxyEKZI+DQGJI8GJijGIP4lDQmM9A66Zb3DezeUviPg0Xn/BOUp+c29x/qhb",
	"rl0IkBkbDXKuxCRZUlshCB/ZpUxIMEXPM94J3SRdDlEcdZjFnXcukso21hKUiGV3dzKnU3+FdhyqT/8y",
	"PtWOCBtSBbnTzjQImHnbaHhZwk77eG/yt7AVehu9fTTZYOrGPOlzfSfLu43iDiMJGhVAmY4/UYrZZ9yq",
	"DeuzboAbl6NzRMpVoLW2YChWe6sVYmrkLg9jRdacYNKgM2PLq/flj+WZSBbQrvtLl3/QTyNRHj4WAmUv",
	"0PaeAFJYlopOHIxwO/cT1gn+3LneKA81N0YnUmNwKviEGeu3PuvZNgFko28Z1VNnCVKxB1YiEdVQCsLh",
	"4bJQ6VPxJeGBZHVAA1cZkFLObXzaMFhVHOTQk6v+xF00NCjNNtocPhG2KItraovObWHoCTb99x3VlMNc",
	"HPtinhr0E+9D8iu5oGNFzrl/7A282Hi13kzrSJ0Mh6UHqwGMnIAvZObdous7Go28xF/+NMlCUBlZ9UCn",
	"U5DHTAyxz9B0ZjosSTUajcipkFhnny523uvjV8evMEEdAacR8068t/jTwMMQkhn60Gbg72AxfMxmamla",
	"puDIiv0GmoRJGIqGIbFPkztYmB2wAS1No72mb1bwfMGURraSzkFj0vnzo8cwuWWcoGyei5G7XJ1axjBI",
	"zoG4Kg2+4oqLxVo4qjevXqUqTpJ7NIpCu7/jw2/KYjGn1yokXz2tULODy0JEeiP2q7jaksJlLSLmxRy+",
	"R3Y/C0mfgafi+ZzKxRpNYRZPucov0UlXhBIOD4VHarq1HbMZ2bdqsdTvVxEsdjattZMBFSttxFp2RFVL",
	"/kmRYb/g04gE081tNIaPaWHP0iIrBFuRVIbOGf5+COgMnLQK1UeHMzC1osQeqdoqitCSlgfN9j8ATVlo",
	"j2s0W4ii9f9n6HijtaN3a4Vbq/ZtzyvShuJOoxht1o9PH25GJH+4YRExvU6LnfZh7tMKYMfcVKQkWaJc",
	"eYdcEFZJmDb1dXmoKtqJmsIPw8diOr/obdZsSA0d6w1JqeigLwbgean3CnQsOYHvTGnGpyt1q+g8bGsR",
	"rkcfL9ZbBNNr7xYhrS5yTE5FyqeyCGsk7LVFqCraiZrVFiGKHXC6xbiu4bIOSrZnDUr7Nh8vQO07UJsh",
	"5Abp3NbKrQFrC+OXaYckJDH6Q7cyimlF4HMEtLu0cT2659mYX6Ddxga3xRvCPjtEPkxLZB6zlEFrhBeP",
	"ltsDHm4s55cUtMFvMb325OA9Kxy2r6mnNn6iBaEBVjFhTcNCaZgfFMDt5O0viOtTSqeUcaVxQhMNQ5CV",
	"i6wH8zBWIIePNj+wMtJtZMhIEV9IqyUsvDKKzaL4lAc2VZmkjo5d0ZBsJL8ukiD/iAfvMPOwv7fAHR7J",
	"ciP92Bs9P4x2A0cFoy3zLmWGWaq1GWc7jLpFVGuQ5un/+0yP/h4d/e+ro//88uXo6+Pbwes3vyz/5UjH",
	"PRli3nHN9KLXcBFpFHDgDWdAQz37e1UQ5Peky66D0NVh5FnyaihAZXC24lrRBY31rJQCyLL4qbtQD+hk",
	"1ys8v6RR/faJA2eNHHdT9CuSPIWkTBt9zSSQzAIyJCq/SGAo5LTR0qV4ozx5S8gD0zPCuC0PMxsBCdOk",
	"/JnyzC14mDF/RpgikQSFXG1Bd1o7UgfiQ3oM+ZxPhLdPrRXPtLsCgKX2vkUBd62KFAGt1r0tRXDpu6zs",
	"vlYivOAoV6ILKeW0Agv89dAplUF8Oj87LWx+FRlDKPg08doiexosIKUL8eqm4/zstHBNw3shRxnunnWJ",
	"SyEVUS1tqYFt44nsIyI7YmMtQtPkyAYIrYRntkNoOVr4AyG0EHVbh9DNJ7L3CN1iSC6EyuSekQ1QibXK",
	"W0Hxyjz54wAQ72hpgb6WE9Z7yLUdRxPOho+2iH5tbANB2YCfgxcQyfSEeD88Pws6N8h6GOiwYrkQEScn",
	"XzawPHjh1FaW59Y8+eNYHjw11MLytJyw3luetuNowpkrxu/EyMGtS8/i7xZYbiD1Hkeo/tShaZOkvHKt",
	"M7ZL0rSP0GGTBcebpp48S7hKuv7mBq+yZQYdDapUPIdyRfo63yMnaKOWGJjIs4qZG1BGywg5/VMck7Zp",
	"gz7CZJVWETmqcOVPC+OR30rgrNHJWvdSCJaluOtb3SQ5U/z1oGUya0XrrxUpVQ6k9QIFUZv3LNnpuzQ3",
	"tiopi/SKADm8KlT/VLFyHksaSc4wblaeNAoCG3a2DxO8lrOYna+b9iC4jsB/L2Suq10VZ2ydRW+yJTnp",
	"eRxqFlGphxMh50cBtac0zLhHEXvPrHuU3bAwZtzMv+Oy9OXyBZsJNteDpwTQCiBXhTqawPcb6B6h7gUE",
	"dY2hxtMT/26b42erS3oJiPU/sr0TPu52IG5s0z68hxt70UJt/OZ3rFHKpGXBQX2HJsFuVaGOtEeIaKff",
	"DCjOEkRn8dfQvNbDR/Pf5TClPXzMr5JZY1cMtzTBSpUSPqNmDCicLZa0hFxmxyjhvZBXeZfDViTucouU",
	"XcHTcadVvMLncLutXV/G4tqvIUB7ZmMRvRMhc5jiK5QGjNtszkoWw21gTZf3QhZrJPdhbJsiavbykrzu",
	"4aCGdpVQ/d2eFZVKNIM8TBaBzybmB1Gui0lQM6T4rdjVoUH7PVmMCBi6sY0G16I9yTdnb0QSLt7LsZjS",
	"p22bQoV2UHN7S08/sNPHRdql1xwZybVHK+yK7WAwGK80KrbfHlFRux1qjRJI8Uqng0OkjaS9MjUNes6h",
	"gresNwMFp972qWIj+6jenpBR+mhfEypS0V4sReNx0Hyacq3b+wpoGI6pf9fodeNnwk5pGBLsVgWAaR4l",
	"34KD3ykPwgQL/6hY/BX4wO7B3ueYTimZSDEnZoJqk950ytYexqX+ip13C31cjz5eOHTS40slfjiNYxFb",
	"Ve34Ara6IcShclzqHRbYNKKVfFH0XhR9I9l0ClIRkWqBcTJJP5xW0C6+untTscHTi5qfVs0KdPFDwG77",
	"fA26eE1oWZPXthbnMm9/UnfabNIHmbQYIM0vK33xppqwUlJxDo+2p63RCW/OoppR/8n0TMQbnnJtUXDV",
	"tzRJk+Z7e7r1tqC75WDd9T0rY3W2W+vSvG3L6V7ifrKfF/Pk4Zpi0uT4AcLw6I6LBz789nCnjlOxmi1K",
	"hB9RJ/gN8hnVxKecjMF+8EcLcg+STRb5t4UIfoEaP6mVXua8IkebfaFdPfNsbfm2cbwhuPWBsdKX6uvF",
	"yS2yEdlXzTJd2TxAX5PBVTktchBKiTSWspE/hUN+UfjJcBgKn4YzofTJL69+eeUtvy7/PwAA//+hO6xc",
	"8YwAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
